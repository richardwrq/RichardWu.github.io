<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>RichardWu&#39;s Blog on RichardWu&#39;s Blog</title>
    <link>https://richardwrq.github.io/</link>
    <description>Recent content in RichardWu&#39;s Blog on RichardWu&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <lastBuildDate>Sun, 14 Feb 2021 12:25:28 +0800</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>TCP协议详解</title>
      <link>https://richardwrq.github.io/2021/tcp%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Sun, 14 Feb 2021 12:25:28 +0800</pubDate>
      
      <guid>https://richardwrq.github.io/2021/tcp%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/</guid>
      <description>

&lt;h2 id=&#34;tcp-ip协议详解&#34;&gt;TCP\IP协议详解&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;本文中用到的图片转自： &lt;a href=&#34;https://www.toutiao.com/i6817040378810597892/?tt_from=weixin&amp;amp;utm_campaign=client_share&amp;amp;wxshare_count=1&amp;amp;from=singlemessage&amp;amp;timestamp=1588647290&amp;amp;app=news_article&amp;amp;utm_source=weixin&amp;amp;isappinstalled=0&amp;amp;utm_medium=toutiao_ios&amp;amp;req_id=2020050510545001002302815727C1E4DA&amp;amp;group_id=6817040378810597892&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;头条文章&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&#34;tcp与udp协议有什么区别&#34;&gt;TCP与UDP协议有什么区别？&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;TCP是一个面向连接的、可靠的、基于字节流的传输层协议。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;UDP是一个面向无连接的传输层协议。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;与UDP相比，TCP有以下特性：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;面向连接&lt;/strong&gt;。所谓的连接，指的是客户端和服务器的连接，在双方互相通信之前，TCP 需要三次握手建立连接，而 UDP 没有相应建立连接的过程。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可靠性&lt;/strong&gt;。TCP 使用了非常多机制的保证连接的可靠，这个可靠性体现在哪些方面呢？一个是有状态，另一个是可控制。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;面向字节流&lt;/strong&gt;。UDP 的数据传输是基于数据报的，这是因为仅仅只是继承了 IP 层的特性，而 TCP 为了维护状态，将一个个 IP 包变成了字节流。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;TCP 会精准记录哪些数据发送了，哪些数据被对方接收了，哪些没有被接收到，而且保证数据包按序到达，不允许半点差错。这是&lt;strong&gt;有状态&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;当意识到丢包了或者网络环境不佳，TCP 会根据具体情况调整自己的行为，控制自己的发送速度或者重发。这是&lt;strong&gt;可控制&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;相应的，UDP 就是无状态, 不可控的。&lt;/p&gt;

&lt;h3 id=&#34;三次握手&#34;&gt;三次握手&lt;/h3&gt;

&lt;p&gt;在介绍三次握手时我们先来看看TCP的报文头格式：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://richardwrq.github.io/TCP详解/823435-20170323092941611-1541980584.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;端口号&lt;/strong&gt;：用来标识同一台计算机的不同的应用进程。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;源端口&lt;/strong&gt;：源端口和IP地址的作用是标识报文的返回地址。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;目的端口&lt;/strong&gt;：端口指明接收方计算机上的应用程序接口。（TCP报头中的源端口号和目的端口号同IP数据报中的源IP与目的IP唯一确定一条TCP连接。）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;序号和确认号&lt;/strong&gt;：是TCP可靠传输的关键部分。&lt;strong&gt;序号&lt;/strong&gt;是本报文段发送的数据组的第一个字节的序号。在TCP传送的流中，每一个字节一个序号。e.g.一个报文段的序号为300，此报文段数据部分共有100字节，则下一个报文段的序号为400。所以序号确保了TCP传输的有序性。确认号，即ACK，指明下一个期待收到的字节序号，表明该序号之前的所有数据已经正确无误的收到。确认号只有当ACK标志为1时才有效。比如建立连接时，SYN报文的ACK标志位为0。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数据偏移／首部长度&lt;/strong&gt;：4bits。由于首部可能含有可选项内容，因此TCP报头的长度是不确定的，报头不包含任何可选字段则长度为20字节，4位首部长度字段所能表示的最大值为1111，转化为10进制为15，15*&lt;sup&gt;32&lt;/sup&gt;&amp;frasl;&lt;sub&gt;8&lt;/sub&gt; = 60，故报头最大长度为60字节。首部长度也叫数据偏移，是因为首部长度实际上指示了数据区在报文段中的起始偏移值。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;保留&lt;/strong&gt;：为将来定义新的用途保留，现在一般置0。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;控制位&lt;/strong&gt;：URG  ACK  PSH  RST  SYN  FIN，共6个，每一个标志位表示一个控制功能。

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;URG&lt;/strong&gt;：紧急指针标志，为1时表示紧急指针有效，为0则忽略紧急指针。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ACK&lt;/strong&gt;：确认序号标志，为1时表示确认号有效，为0表示报文中不含确认信息，忽略确认号字段。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;PSH&lt;/strong&gt;：push标志，为1表示是带有push标志的数据，指示接收方在接收到该报文段以后，应尽快将这个报文段交给应用程序，而不是在缓冲区排队。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;RST&lt;/strong&gt;：重置连接标志，用于重置由于主机崩溃或其他原因而出现错误的连接。或者用于拒绝非法的报文段和拒绝连接请求。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SYN&lt;/strong&gt;：同步序号，用于建立连接过程，在连接请求中，SYN=1和ACK=0表示该数据段没有使用捎带的确认域，而连接应答捎带一个确认，即SYN=1和ACK=1。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;FIN&lt;/strong&gt;：finish标志，用于释放连接，为1时表示发送方已经没有数据发送了，即关闭本方数据流。&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;窗口&lt;/strong&gt;：滑动窗口大小，用来告知发送端接受端的缓存大小，以此控制发送端发送数据的速率，从而达到流量控制。窗口大小16bit，因此窗口大小最大为65535。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;校验和&lt;/strong&gt;：奇偶校验，此校验和是对整个的 TCP 报文段，包括 TCP 头部和 TCP 数据，以 16 位字进行计算所得。由发送端计算和存储，并由接收端进行验证。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;紧急指针&lt;/strong&gt;：只有当 URG 标志置 1 时紧急指针才有效。紧急指针是一个正的偏移量，和顺序号字段中的值相加表示紧急数据最后一个字节的序号。 TCP 的紧急方式是发送端向另一端发送紧急数据的一种方式。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;选项和填充&lt;/strong&gt;：最常见的可选字段是最长报文大小，又称为MSS（Maximum Segment  Size），每个连接方通常都在通信的第一个报文段（为建立连接而设置SYN标志为1的那个段）中指明这个选项，它表示本端所能接受的最大报文段的长度。选项长度不一定是32位的整数倍，所以要加填充位，即在这个字段中加入额外的零，以保证TCP头是32的整数倍。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数据部分&lt;/strong&gt;： TCP 报文段中的数据部分是可选的。在一个连接建立和一个连接终止时，双方交换的报文段仅有 TCP 首部。如果一方没有数据要发送，也使用没有任何数据的首部来确认收到的数据。在处理超时的许多情况中，也会发送不带任何数据的报文段。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;报头格式介绍完了，接下来我们看看TCP的三次握手过程：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://richardwrq.github.io/TCP详解/823435-20170323092953893-1865298744.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;过程描述：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;客户端发起连接请求，报头中的SYN=1，ACK=0，TCP规定SYN=1时不能携带数据，但要消耗一个序号,因此声明自己的序号是 seq=x。此时客户端状态&lt;strong&gt;CLOSED&lt;/strong&gt;-&amp;gt;&lt;strong&gt;SYN-SENT&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;服务器接收到连接请求，然后进行回复确认，发送SYN=1 ACK=1 seq=y ack=x+1。此时服务端状态&lt;strong&gt;LISTEN&lt;/strong&gt;-&amp;gt;&lt;strong&gt;SYN-RCVD&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;客户端收到对SYN的确认包之后再次确认，SYN=0 ACK=1 seq=x+1 ack=y+1，此时客户端状态&lt;strong&gt;SYN-SENT&lt;/strong&gt;-&amp;gt;&lt;strong&gt;ESTABLISHED&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;服务端接收到客户端的确认包后状态变为&lt;strong&gt;ESTABLISHED&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;为什么要进行三次握手？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;保证通信是“全双工”的，即客户端和服务器都具备发送和接收能力，假如没有客户端的第二次确认，那么服务端无法确保客户端已经接收到自己发出去的SYN确认包。而且假如只有两次握手，那么会存在资源浪费的情况：&lt;/p&gt;

&lt;p&gt;客户端发出SYN请求后，由于网络复杂情况，这个请求一直没有发送到服务器端，这时候客户端超时重发第二个请求，然后第二个请求服务端正常接收并建立连接，数据传输完毕后双方断开了连接，但这时候第一次发送的那个SYN包终于到达服务端了，由于是二次握手，所以服务端发送确认包，并建立连接，但是客户端实际上已经断开连接了，而服务端建立了一条“没有”客户端的连接，造成了资源浪费。&lt;/p&gt;

&lt;h4 id=&#34;重传机制&#34;&gt;重传机制&lt;/h4&gt;

&lt;p&gt;三次握手结束之后就可以开始收发数据了，那要怎么保证我们发送出去的消息确实被接收到了呢？以寄快递为例，虽然我们寄快递前确认收件人信息无误，但是快递寄出去的时候，如果我们没有收到反馈（比如收件人告知你快递我已经收到了或者是快递公司的收件通知）。那么我们是无法知道快递是否准确送达的。&lt;/p&gt;

&lt;p&gt;在TCP中，是通过序列号与确认应答来保证的（回想下上面的报头格式）。正常的传输过程如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://richardwrq.github.io/TCP详解/6f12b7827bba411b8d20d8a8b5b50bba.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;但是实际情况是非常复杂的，假如网络出现丢包的情况要怎么办呢？这就涉及到TCP的&lt;strong&gt;重传机制&lt;/strong&gt;：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;超时重传&lt;/li&gt;
&lt;li&gt;快速重传&lt;/li&gt;
&lt;li&gt;SACK&lt;/li&gt;
&lt;li&gt;D-SACK&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;超时重传&#34;&gt;超时重传&lt;/h4&gt;

&lt;p&gt;在发送数据时，设定一个定时器，当超过指定的时间后，没有收到对方的 ACK 确认应答报文，就会重发该数据。&lt;/p&gt;

&lt;p&gt;在&lt;strong&gt;数据包丢失&lt;/strong&gt;或者&lt;strong&gt;确认应答丢失&lt;/strong&gt;时会发生超时重传：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://richardwrq.github.io/TCP详解/1189ad86c82847d5a4d2a325312bfab4.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;问题来了，这个“特定的时间间隔”应该设置成多少合适呢？这就引入了RTT（Round-Trip Time 往返时延）的概念：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://richardwrq.github.io/TCP详解/cf10b4cef2284178942306dcd5ac17a8.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;RTT简单来说就是&lt;strong&gt;数据一次往返的时间&lt;/strong&gt;，超时重传时间是以 RTO （Retransmission Timeout 超时重传时间）表示。这个重传时间的设置比较玄学，设置高了或者低了都会有问题：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://richardwrq.github.io/TCP详解/9a0a2e09eee245b8a2fdac908530fb96.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;其实不用看图片大家应该也能猜到，超时时间过大，那么就会导致效率的降低（大部分时间都用来等待）。超时时间过低的话那就有可能造成不必要的重传（重传刚发出去结果就收到了应答）。&lt;/p&gt;

&lt;p&gt;所以RTO的计算方法比较复杂，因为网络状态是时时刻刻变化的，而且也会存在波动较大的情况，所以RTO的值也是动态变化的，这里面的算法就不赘述了~~~有兴趣的小伙伴可以网上查找相关资料。&lt;/p&gt;

&lt;h5 id=&#34;快速重传&#34;&gt;快速重传&lt;/h5&gt;

&lt;p&gt;我们一直强调网络情况是非常复杂的，所以上面提到的超时重传无法解决所有问题，设想这么一种场景：数据包只是因为某一个网络节点的异常而丢失了，实际上网路是“畅通”的，假如还是使用超时重传那么效率显然太低了，因此，快速重传机制诞生了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://richardwrq.github.io/TCP详解/fd8888b8b0b440788f3c875d1ba4436c.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;发送端发送了5份数据；&lt;/li&gt;
&lt;li&gt;接收方接收到seq1时返回ACK2，但是seq2由于网络异常丢包没有收到；&lt;/li&gt;
&lt;li&gt;这时候接收端又接收到seq3，在应答的时候依然返回ACK2；&lt;/li&gt;
&lt;li&gt;后续seq4和seq5也收到了，但是seq2还没有收到，依然返回ACK2。&lt;/li&gt;
&lt;li&gt;发送端连续收到三次同样的ACK2，知道seq2没有被接收到，就会在定时器任务触发之前重传seq2。&lt;/li&gt;
&lt;li&gt;接收端接收到seq2，而且检测到seq3、4、5都已经收到。所以返回ACK6&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;所以，快速重传的工作方式是当收到三个相同的 ACK 报文时，会在定时器过期之前，重传丢失的报文段。&lt;/p&gt;

&lt;p&gt;但是快速重传也有问题，发送端只知道seq2丢失了，但是不知道seq3、4、5有没有被接收到。所以发送端并不清楚要不要把后续的seq3、4、5一并重传。于是便引入了SACK&lt;/p&gt;

&lt;h5 id=&#34;sack-selective-acknowledgment-选择性确认&#34;&gt;SACK（ Selective Acknowledgment 选择性确认）&lt;/h5&gt;

&lt;p&gt;这种方式需要在 TCP 头部「选项」字段里加一个 SACK，他可以记录已接收的数据，随着报头一起发送给发送方，这样发送方就清楚什么数据被接收了，什么数据没有接收，这样就可以只重传丢失的数据。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://richardwrq.github.io/TCP详解/7135037248b348c2bf2d37e46750ff9d.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;发送方收到了三次同样的 ACK 确认报文，于是就会触发快速重发机制，通过SACK 信息发现只有 200~299 这段数据丢失，重发时只需要重传这段数据即可。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;如果要支持 SACK，必须双方都要支持。在 Linux 下，可以通过 net.ipv4.tcp_sack参数打开这个功能（Linux 2.4 后默认打开）。
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;duplicate-sack&#34;&gt;Duplicate SACK&lt;/h5&gt;

&lt;p&gt;Duplicate SACK 又称 D-SACK，其主要&lt;strong&gt;使用了 SACK 来告诉「发送方」有哪些数据被重复接收了。&lt;/strong&gt; 主要解决下面两种情况：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://richardwrq.github.io/TCP详解/732bc94fd4714c95ae94262f15224d3e.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;ACK丢包。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://richardwrq.github.io/TCP详解/ab58dca206e14b35a0fbed4d6799113e.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;网络延时。&lt;/p&gt;

&lt;p&gt;在 Linux 下可以通过 net.ipv4.tcp_dsack 参数开启/关闭这个功能（Linux 2.4 后默认打开）。&lt;/p&gt;

&lt;h4 id=&#34;滑动窗口&#34;&gt;滑动窗口&lt;/h4&gt;

&lt;p&gt;细心的小伙伴可能发现了，上面的图片里面并不是等到上一次数据的确认收到之后才发送下一批数据，因为串行发送数据效率太低，所以TCP引入了&lt;strong&gt;滑动窗口&lt;/strong&gt;的概念。&lt;/p&gt;

&lt;p&gt;有了窗口，就可以指定窗口大小，窗口大小就是指&lt;strong&gt;无需等待确认应答，而可以继续发送数据的最大值&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;窗口的实现实际上是操作系统开辟的一个缓存空间，发送方主机在等到确认应答返回之前，必须在缓冲区中保留已发送的数据。如果按期收到确认应答，此时数据就可以从缓存区清除。&lt;/p&gt;

&lt;p&gt;假设窗口大小为 3 个 TCP 段，那么发送方就可以「连续发送」 3 个 TCP 段，并且中途若有 ACK 丢失，可以通过「下一个确认应答进行确认」。如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://richardwrq.github.io/TCP详解/04973b1e0f99426cad89c0e8a826c6ac.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;图中的 ACK 600 确认应答报文丢失，也没关系，因为可以通过下一个确认应答进行确认，只要发送方收到了 ACK 700 确认应答，就意味着 700 之前的所有数据「接收方」都收到了。这个模式就叫&lt;strong&gt;累计确认&lt;/strong&gt;或者&lt;strong&gt;累计应答&lt;/strong&gt;。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;那么窗口大小应该怎么设置呢？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;回想一下TCP报头格式，是不是有一个“窗口”字段？这个“窗口”字段就是用来表示窗口大小的。&lt;strong&gt;这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据接收端的处理能力来发送数据，而不会导致接收端处理不过来。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;所以，通常窗口的大小是由接收方的决定的。&lt;/p&gt;

&lt;p&gt;发送方发送的数据大小不能超过接收方的窗口大小，否则接收方就无法正常接收到数据。&lt;/p&gt;

&lt;p&gt;下图就是发送方缓存的数据，根据处理的情况分成四个部分，其中深蓝色方框是发送窗口，紫色方框是可用窗口：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://richardwrq.github.io/TCP详解/b441c3f5328a42c6b00ff34b02391aa4.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;在下图，当发送方把数据「全部」都一下发送出去后，可用窗口的大小就为 0 了，表明可用窗口耗尽，在没收到 ACK 确认之前是无法继续发送数据了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://richardwrq.github.io/TCP详解/fbec4c0bf70e4f6991cac1f3464b06f2.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;在下图，当收到之前发送的数据 32~36 字节的 ACK 确认应答后，如果发送窗口的大小没有变化，则&lt;strong&gt;滑动窗口往右边移动 5 个字节，因为有 5 个字节的数据被应答确认&lt;/strong&gt;，接下来 52~56 字节又变成了可用窗口，那么后续也就可以发送 52~56 这 5 个字节的数据了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://richardwrq.github.io/TCP详解/991afb2eae7e4a4794b85b5b3ac3a7c6.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;TCP 滑动窗口方案使用三个指针来跟踪在四个传输类别中的每一个类别中的字节。其中两个指针是绝对指针（指特定的序列号），一个是相对指针（需要做偏移）。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://richardwrq.github.io/TCP详解/ce6a66c5f9254eca8324cf4b57772fc0.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;SND.WND：表示发送窗口的大小（大小是由接收方指定的）；&lt;/li&gt;
&lt;li&gt;SND.UNA：是一个绝对指针，它指向的是已发送但未收到确认的第一个字节的序列号，也就是 #2 的第一个字节。&lt;/li&gt;
&lt;li&gt;SND.NXT：也是一个绝对指针，它指向未发送但可发送范围的第一个字节的序列号，也就是 #3 的第一个字节。&lt;/li&gt;
&lt;li&gt;指向 #4 的第一个字节是个相对指针，它需要 SND.NXT 指针加上 SND.WND大小的偏移量，就可以指向 #4 的第一个字节了。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;可用窗口大小 = SND.WND -（SND.NXT - SND.UNA）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;接下来是接收端的窗口&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://richardwrq.github.io/TCP详解/1e87fab0380f4dc5b1dbb102ebee3cf0.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;RCV.WND：表示接收窗口的大小，它会通告给发送方。&lt;/li&gt;
&lt;li&gt;RCV.NXT：是一个指针，它指向期望从发送方发送来的下一个数据字节的序列号，也就是 #3 的第一个字节。&lt;/li&gt;
&lt;li&gt;指向 #4 的第一个字节是个相对指针，它需要 RCV.NXT 指针加上 RCV.WND大小的偏移量，就可以指向 #4 的第一个字节了。&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;接收窗口≈发送窗口&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;因为滑动窗口是一直在变化的，假如接收方的应用读取数据的速度很快，那么接收窗口就很快就可以腾出空间，但是在把新的接收窗口大小发给发送端的时候是存在时延的，所以发送窗口约等于接收窗口。&lt;/p&gt;

&lt;h4 id=&#34;流量控制&#34;&gt;流量控制&lt;/h4&gt;

&lt;p&gt;从上面我们可以知道接收端是有接收窗口的，接收方的应用在处理数据时也需要一定的时间，假如发送方不加以控制，那么接收方将无法处理过多的数据，导致出发重传机制，从而浪费网络流量。&lt;/p&gt;

&lt;p&gt;为了解决这种现象发生，&lt;strong&gt;TCP 提供一种机制可以让「发送方」根据「接收方」的实际接收能力控制发送的数据量，这就是所谓的流量控制。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我们先看看假设接收窗口和发送窗口保持200不变的发送过程：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://richardwrq.github.io/TCP详解/12b6a363c7a34ce7934bfe3f378e32e5.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;客户端发送请求数据报文。&lt;/li&gt;
&lt;li&gt;服务端接收到请求，发送确认以及80字节数据，这时发送窗口的SND.UNA = 241, SND.NXT = SND.WND + 80 = 321。可用发送窗口大小 = 200 - ( 321 - 241) = 120。&lt;/li&gt;
&lt;li&gt;客户端接收到数据，这时接收窗口RCV.NXT = RCV.NXT + 80 = 321，发送确认报文。&lt;/li&gt;
&lt;li&gt;发送端继续发送120个字节，由于这时还没收到客户端的确认数据包，发送窗口SND.UNA = 241, SND.NXT = 321 + 120 = 441，可用发送窗口大小 = 200 - (441 - 241) = 0，可用窗口大小为0，这时无法再发送数据。&lt;/li&gt;
&lt;li&gt;客户端接收到120字节数据，RCV.NXT = 321 + 120 = 441，发送确认报文。&lt;/li&gt;
&lt;li&gt;服务端收到客户端的第一个确认报文，窗口往右”滑动“80字节，SND.UNA = 241 + 80 = 321, 可用发送窗口大小 = 200 - (441 - 321) = 80。&lt;/li&gt;
&lt;li&gt;服务端收到客户端的第二个确认报文，窗口往右”滑动“120字节，SND.UNA = 321 + 120 = 441, 可用发送窗口大小 = 200 - (441 - 441) = 200。&lt;/li&gt;
&lt;li&gt;服务端继续发送160个字节数据，SND.NXT = 441 + 160 = 601，可用发送窗口大小 = 200 - (601 - 441) = 40。&lt;/li&gt;
&lt;li&gt;客户端接收到数据，RCV.NXT = 441 + 160 = 601，发送确认报文。&lt;/li&gt;
&lt;li&gt;服务端收到确认报文，窗口右移160个字节，SND.UNA = 441 + 160 = 601，可用发送窗口大小 = 200 - (601 - 601) = 200。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;上面的例子我们假定了发送窗口和接收窗口是不变的，但是实际上，发送窗口和接收窗口中所存放的字节数，都是放在操作系统内存缓冲区中的，而操作系统的缓冲区，会&lt;strong&gt;被操作系统调整&lt;/strong&gt;。当应用进程没办法及时读取缓冲区的内容时，也会对我们的缓冲区造成影响。&lt;/p&gt;

&lt;p&gt;我们来看下面这个例子：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://richardwrq.github.io/TCP详解/dd15c2eaed554c5e8d1a6074f9287f9a.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;客户端发送 140 字节数据后，可用窗口变为 220 （360 - 140）。&lt;/li&gt;
&lt;li&gt;服务端收到 140 字节数据，&lt;strong&gt;但是服务端非常繁忙，应用进程只读取了 40 个字节，还有 100 字节占用着缓冲区，于是接收窗口收缩到了 260 （360 - 100）&lt;/strong&gt;，最后发送确认信息时，将窗口大小通过给客户端。&lt;/li&gt;
&lt;li&gt;客户端收到确认和窗口通告报文后，发送窗口减少为 260。&lt;/li&gt;
&lt;li&gt;客户端发送 180 字节数据，此时可用窗口减少到 80。&lt;/li&gt;
&lt;li&gt;服务端收到 180 字节数据，&lt;strong&gt;但是应用程序没有读取任何数据，这 180 字节直接就留在了缓冲区，于是接收窗口收缩到了 80 （260 - 180）&lt;/strong&gt;，并在发送确认信息时，通过窗口大小给客户端。&lt;/li&gt;
&lt;li&gt;客户端收到确认和窗口通告报文后，发送窗口减少为 80。&lt;/li&gt;
&lt;li&gt;客户端发送 80 字节数据后，可用窗口耗尽。&lt;/li&gt;
&lt;li&gt;服务端收到 80 字节数据，&lt;strong&gt;但是应用程序依然没有读取任何数据，这 80 字节留在了缓冲区，于是接收窗口收缩到了 0&lt;/strong&gt;，并在发送确认信息时，通过窗口大小给客户端。&lt;/li&gt;
&lt;li&gt;客户端收到确认和窗口通告报文后，发送窗口减少为 0。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;可见最后窗口都收缩为 0 了，也就是发生了窗口关闭。我们再来看下面的例子：&lt;/p&gt;

&lt;p&gt;当服务端系统资源非常紧张的时候，操心系统可能会直接减少了接收缓冲区大小，这时应用程序又无法及时读取缓存数据，会出现数据包丢失的现象。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://richardwrq.github.io/TCP详解/f1d7e77abbda46469059356ab5bef342.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;客户端发送 140 字节的数据，于是可用窗口减少到了 220。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;服务端因为现在非常的繁忙，操作系统于是就把接收缓存减少了 100 字节，当收到 对 140 数据确认报文后，又因为应用程序没有读取任何数据，所以 140 字节留在了缓冲区中，于是接收窗口大小从 360 收缩成了 100&lt;/strong&gt;，最后发送确认信息时，通告窗口大小给对方。&lt;/li&gt;
&lt;li&gt;此时客户端因为还没有收到服务端的通告窗口报文，所以不知道此时接收窗口收缩成了 100，客户端只会看自己的可用窗口还有 220，所以客户端就发送了 180 字节数据，于是可用窗口减少到 40。&lt;/li&gt;
&lt;li&gt;服务端收到了 180 字节数据时，&lt;strong&gt;发现数据大小超过了接收窗口的大小，于是就把数据包丢弃了。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;客户端收到服务端发送的确认报文和通告窗口报文，尝试减少发送窗口到 100，把窗口的右端向左收缩了 80，此时可用窗口的大小就会出现诡异的负值。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;所以，如果发生了先减少缓存，再收缩窗口，就会出现丢包的现象。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;为了防止这种情况发生，TCP 规定是不允许同时减少缓存又收缩窗口的，而是采用先收缩窗口，过段时间再减少缓存，这样就可以避免了丢包情况。&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&#34;窗口关闭&#34;&gt;窗口关闭&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;如果窗口大小为 0 时，就会阻止发送方给接收方传递数据，直到窗口变为非 0 为止，这就是窗口关闭。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;窗口大小是通过ACK报文发送的，当发生窗口关闭时，接收方处理完数据后，会向发送方通告一个窗口非 0 的 ACK 报文，如果这个通告窗口的 ACK 报文在网络中丢失了，那么就会产生“死锁”：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://richardwrq.github.io/TCP详解/43313a8faf394caa91e79f5b98a588ff.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;发送方一直等待接收方的非 0 窗口通知，接收方也一直等待发送方的数据，如不不采取措施，这种相互等待的过程，会造成了死锁的现象。&lt;/p&gt;

&lt;p&gt;为了解决这个问题，TCP 为每个连接设有一个持续定时器，&lt;strong&gt;只要 TCP 连接一方收到对方的零窗口通知，就启动持续计时器。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如果持续计时器超时，就会发送&lt;strong&gt;窗口探测 ( Window probe ) 报文&lt;/strong&gt;，而对方在确认这个探测报文时，给出自己现在的接收窗口大小。窗口探测的次数一般为 3 次，每次大约 30-60 秒（不同的系统版本实现可能会不一样）。如果探测 3 次过后接收窗口还是 0 的话，有的 TCP 实现就会发 RST 报文来中断连接。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://richardwrq.github.io/TCP详解/aaf3fcf91251423bac05cc99d7488f7a.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;糊涂窗口综合征&#34;&gt;糊涂窗口综合征&lt;/h4&gt;

&lt;p&gt;如果接收方太忙了，来不及取走接收窗口里的数据，那么就会导致发送方的发送窗口越来越小。&lt;/p&gt;

&lt;p&gt;到最后，&lt;strong&gt;如果接收方腾出几个字节并告诉发送方现在有几个字节的窗口，而发送方会义无反顾地发送这几个字节，这就是糊涂窗口综合症&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;我们的 TCP + IP 头至少有 40 个字节，假如接收窗口只有几字节，那么就会出现大马拉小车的情况，造成资源浪费。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://richardwrq.github.io/TCP详解/5acc0648ee364bbba1917ea0a662d729.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;参考上图我们不难想象会有两种场景导致“大马拉小车”：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;接收端发送了一个接收窗口很小的ACK包；&lt;/li&gt;
&lt;li&gt;发送端任性的发送小数据包。&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;如何避免发送小窗口ACK包&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;当「窗口大小」小于 min( MSS，缓存空间/2 ) ，也就是小于 MSS 与 &lt;sup&gt;1&lt;/sup&gt;&amp;frasl;&lt;sub&gt;2&lt;/sub&gt; 缓存大小中的最小值时，就会向发送方通告窗口为 0，也就阻止了发送方再发数据过来。&lt;/p&gt;

&lt;p&gt;等到接收方处理了一些数据后，窗口大小 &amp;gt;= MSS，或者接收方缓存空间有一半可以使用，就可以把窗口打开让发送方发送数据过来。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;如何防止发送端发送小数据包&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;使用 Nagle 算法，该算法的思路是延时处理，它满足以下两个条件中的一条才可以发送数据&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;要等到窗口大小 &amp;gt;= MSS 或是 数据大小 &amp;gt;= MSS&lt;/li&gt;
&lt;li&gt;收到之前发送数据的 ack 回包&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;只要没满足上面条件中的一条，发送方就一直囤积数据，直到满足上面的发送条件。&lt;/p&gt;

&lt;p&gt;另外，Nagle 算法默认是打开的，如果对于一些需要小数据包交互的场景的程序，比如，telnet 或 ssh 这样的交互性比较强的程序，则需要关闭 Nagle 算法。&lt;/p&gt;

&lt;p&gt;可以在 Socket 设置 TCP_NODELAY 选项来关闭这个算法（关闭 Nagle 算法没有全局参数，需要根据每个应用自己的特点来关闭）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;setsockopt(sock_fd, IPPROTO_TCP, TCP_NODELAY, (char *)&amp;amp;value, sizeof(int));
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;拥塞控制&#34;&gt;拥塞控制&lt;/h4&gt;

&lt;p&gt;可能有的小伙伴会有疑问，前面既然有了流量控制，为什么还需要一个拥塞控制呢？其实细想我们不难发现，流量控制只是避免了发送方向接收方发送过多的数据，防止接收方无法及时响应。他们并不能感知到当前的网络状态是否拥堵。这就好比平时节假日出游时，我们总能遇到堵车的情况一样，因为在出门的时候我们没有查询当前的交通情况，刚好大部分人都选择在同一天出行，那显然就容易出现交通拥堵的情况了。&lt;/p&gt;

&lt;p&gt;要解决这个问题也不难，只要大家在出门前先通过APP查询当前交通状况，如果发现交通已经比较拥挤了，那就选择改天再出门，选择错峰出行，那交通出现拥堵的概率就会降低。&lt;/p&gt;

&lt;p&gt;TCP其实也是通过类似的方式去解决网络拥塞的，当网络发送拥塞时，TCP 会选择降低发送的数据量。&lt;/p&gt;

&lt;h5 id=&#34;拥塞窗口&#34;&gt;拥塞窗口&lt;/h5&gt;

&lt;p&gt;在介绍拥塞控制算法前先介绍一个概念，&lt;strong&gt;拥塞窗口（CWND）&lt;/strong&gt;。它是发送方维护的一个 的状态变量，它会根据&lt;strong&gt;网络的拥塞程度动态变化&lt;/strong&gt;，前面提到过发送窗口 swnd 和接收窗口 rwnd 是约等于的关系，那么由于入了拥塞窗口的概念后，此时发送窗口的值是swnd = min(cwnd, rwnd)，也就是拥塞窗口和接收窗口中的最小值。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;只要网络中没有出现拥塞，cwnd 就会增大&lt;/li&gt;
&lt;li&gt;网络中出现了拥塞，cwnd 就减小&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;接下来我们先解决第一个问题，TCP怎么知道当前的网络是否拥塞呢？&lt;/p&gt;

&lt;p&gt;很简单，只要发送端没有在规定的时间内收到ACK应答报文（触发了超时重传），那么就认为网络出现了拥塞。&lt;/p&gt;

&lt;p&gt;判断网络出现拥塞后，TCP就会执行下面四个算法：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;慢启动&lt;/li&gt;
&lt;li&gt;拥塞避免&lt;/li&gt;
&lt;li&gt;拥塞发生&lt;/li&gt;
&lt;li&gt;快速恢复&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;慢启动&#34;&gt;慢启动&lt;/h5&gt;

&lt;p&gt;TCP在连接建立之时，会通过&lt;strong&gt;慢启动&lt;/strong&gt;的方式逐渐增加发送数据量。&lt;strong&gt;慢启动&lt;/strong&gt;算法核心是：&lt;strong&gt;当发送方每收到一个 ACK，就拥塞窗口 cwnd 的大小就会加 1&lt;/strong&gt;。假定拥塞窗口 cwnd 和发送窗口 swnd 相等。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;连接建立完成后，一开始初始化 cwnd = 1，表示可以传一个 MSS（MSS就是连接请求时在报头设置的字段）大小的数据。&lt;/li&gt;
&lt;li&gt;当收到一个 ACK 确认应答后，cwnd 增加 1，于是一次能够发送 2 个&lt;/li&gt;
&lt;li&gt;当收到 2 个的 ACK 确认应答后， cwnd 增加 2，于是就可以比之前多发2 个，所以这一次能够发送 4 个&lt;/li&gt;
&lt;li&gt;当这 4 个的 ACK 确认到来的时候，每个确认 cwnd 增加 1， 4 个确认 cwnd 增加 4，于是就可以比之前多发 4 个，所以这一次能够发送 8 个。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://richardwrq.github.io/TCP详解/64e25531483f45609e8afab1cbf13659.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;慢启动窗口是呈指数增长的，如果任由它一直增长下去毫无疑问网络会出现拥堵，所以TCP设置了一个阈值，它就是慢启动门限 ssthresh （slow start threshold）状态变量。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;当 cwnd &amp;lt; ssthresh 时，使用慢启动算法。&lt;/li&gt;
&lt;li&gt;当 cwnd &amp;gt;= ssthresh 时，就会使用「拥塞避免算法」。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;拥塞避免算法&#34;&gt;拥塞避免算法&lt;/h5&gt;

&lt;p&gt;当拥塞窗口 cwnd 「超过」慢启动门限 ssthresh 就会进入拥塞避免算法。一般来说 ssthresh 的大小是 65535 字节。进入拥塞避免算法后，它的规则是：&lt;strong&gt;每当收到一个 ACK 时，cwnd 增加 1/cwnd。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;接上前面的慢启动的例子，假定 ssthresh 为 8：&lt;/p&gt;

&lt;p&gt;当 8 个 ACK 应答确认到来时，每个确认增加 1/8，8 个 ACK 确认 cwnd 一共增加 1，于是这一次能够发送 9 个 MSS 大小的数据，变成了&lt;strong&gt;线性增长&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://richardwrq.github.io/TCP详解/7755f60e427b4ed2bdd1aa769b8512cd.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;拥塞避免算法就是将原本慢启动算法的指数增长变成了线性增长。&lt;/p&gt;

&lt;p&gt;随着发送量增大，网络慢慢就会出现拥塞，这时候就会出现丢包，进而触发重传。当触发重传机制，那么就会启动&lt;strong&gt;拥塞发生算法&lt;/strong&gt;。&lt;/p&gt;

&lt;h5 id=&#34;拥塞发生&#34;&gt;拥塞发生&lt;/h5&gt;

&lt;p&gt;需要注意的是，上面我们介绍过两种重传机制：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;超时重传&lt;/li&gt;
&lt;li&gt;快速重传&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这两种重传机制对应两种不同的异常：超时重传是网络出现拥堵，无法快速处理所有数据包，所以导致数据包“堵”在网络当中；而快速重传是由于网络异常从而导致某一个数据包“失踪”了，而网络实际是畅通的。&lt;/p&gt;

&lt;p&gt;因此针对这两种异常，TCP同样选择两种算法处理：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;拥塞发生&amp;lt;=&amp;gt;超时重传&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;ssthresh 设为 cwnd/2，&lt;/li&gt;
&lt;li&gt;cwnd 重置为 1&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://richardwrq.github.io/TCP详解/6310fe3872a04422bd251960507a06d1.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;从图中不难看出，这种算法呈现的是“断崖式下跌”（还好不是股市）。如果只采用这种拥塞发生算法的话，那么网络的波动就会非常大，体现在打游戏时突然延迟很高~~&lt;/p&gt;

&lt;p&gt;接下来就介绍针对&lt;strong&gt;快速重传&lt;/strong&gt;的拥塞发生算法——&lt;strong&gt;快速恢复&lt;/strong&gt;，因为发送方还能连续收到3个ACK，说明网络情况还比较乐观。ssthresh 和cwnd 变化如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;cwnd = cwnd/2 ，也就是设置为原来的一半;&lt;/li&gt;
&lt;li&gt;ssthresh = cwnd;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;快速恢复&#34;&gt;快速恢复&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;拥塞窗口 cwnd = ssthresh + 3 （ 3 的意思是确认有 3 个数据包被收到了）&lt;/li&gt;
&lt;li&gt;重传丢失的数据包&lt;/li&gt;
&lt;li&gt;如果再收到重复的 ACK，那么 cwnd 增加 1&lt;/li&gt;
&lt;li&gt;如果收到新数据的 ACK 后，设置 cwnd 为 ssthresh，接着就进入了拥塞避免算法&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://richardwrq.github.io/TCP详解/25061b045a9c4883a879a48d57635f6f.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;四次挥手说再见&#34;&gt;四次挥手说再见&lt;/h4&gt;

&lt;p&gt;&lt;img src=&#34;https://richardwrq.github.io/TCP详解/823435-20170323093037486-665986934.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;MSL是Maximum Segment Lifetime的英文缩写，可译为“最长报文段寿命”，它是任何报文在网络上存在的最长的时间，超过这个时间报文将被丢弃。我们都知道IP头部中有个TTL字段，TTL是time to live的缩写，可译为“生存时间”，这个生存时间是由源主机设置初始值但不是存在的具体时间，而是一个IP数据报可以经过的最大路由数，每经过一个路由器，它的值就减1，当此值为0则数据报被丢弃，同时发送ICMP报文通知源主机。RFC793中规定MSL为2分钟，但这完全是从工程上来考虑，对于现在的网络，MSL=2分钟可能太长了一些。因此TCP允许不同的实现可根据具体情况使用更小的MSL值。TTL与MSL是有关系的但不是简单的相等关系，MSL要大于TTL。&lt;/p&gt;

&lt;p&gt;在TIME_WAIT状态时两端的端口不能使用，要等到2MSL时间结束才可继续使用。当连接处于2MSL等待阶段时任何迟到的报文段都将被丢弃。不过在实际应用中可以通过设置SO_REUSEADDR选项达到不必等待2MSL时间结束再使用此端口。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;当客户端没有东西要发送时就要释放连接，客户端会发送一个报文（没有数据），其中 FIN 设置为1,  服务端收到后会恢复确认，这时客户端的连接已经关闭，即客户端不再发送信息（但仍可接收信息）。  客户端收到确认后进入等待状态，等待服务端请求释放连接， 服务端数据发送完毕后就向客户端请求连接释放，同样是用FIN=1 表示， 并且用 ack =  u+1(如图）， 客户端收到后同样回复一个确认，并进入 TIME_WAIT 状态， 等待 2MSL 时间。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;为什么需要等待？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;因为服务端接收到释放连接的请求后会发送确认信息，这个确认信息是有可能丢失的，所以客户端就需要等待，如果超时还没收到确认，那么就会再次发送释放连接的请求。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;为什么客户端在FIN-WAIT-2阶段发送ACK后还需要等待2MSL&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;1.为了保证客户端（我们记为A端）发送的最后一个ACK报文段能够到达服务器端。这个ACK报文段有可能丢失，因而使处在LASK—ACK端的服务器端（我们记为B端）收不到对已发送的FIN+ACK报文段。B会超时重传这个FIN+ACK报文段，而A就能在2MSL时间内收到这个重传的FIN+ACK报文段。接着A重传一次确认，重新启动2MSL计时器。最后，A和B都正常进入到CLOSED状态。如果A在TIME_WAIT状态不等待一段时间，而是在发送完ACK确认后立即释放连接，那么就无法收到B重传的FIN+ACK报文段，因而也不会再发送一次确认报文段，这样，B就无法正常进入CLOSED状态。&lt;/p&gt;

&lt;p&gt;2.我们都知道，假如A发送的第一个请求连接报文段丢失而未收到确认，A就会重传一次连接请求，后来B收到了确认，建立了连接。数据传输完毕后，就释放了连接。A共发送了两个连接请求报文段，其中第一个丢失，第二个到达了B。假如现在A发送的第一个连接请求报文段没有丢失，而是在某些网络节点长时间都留了，以至于延误到连接释放后的某个时间才到达B，这本来是已失效的报文段，但B并不知道，就会又建立一次连接。而等待的这2MSL就是为了解决这个问题的，A在发送完最后一个确认报后，在经过时间2MSL，就可以使本链接持续时间内所产生的所有报文段都从网络中消失，这样就可以使下一个新的连接中不会出现这种旧的连接请求报文段。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>自定义Gradle插件</title>
      <link>https://richardwrq.github.io/2019/%E8%87%AA%E5%AE%9A%E4%B9%89gradle%E6%8F%92%E4%BB%B6/</link>
      <pubDate>Wed, 02 Jan 2019 20:36:28 +0800</pubDate>
      
      <guid>https://richardwrq.github.io/2019/%E8%87%AA%E5%AE%9A%E4%B9%89gradle%E6%8F%92%E4%BB%B6/</guid>
      <description>

&lt;h2 id=&#34;是什么&#34;&gt;是什么&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Gradle&lt;/strong&gt;是一个开源的自动化构建工具，可以使用&lt;code&gt;groovy&lt;/code&gt;或&lt;code&gt;kotlin&lt;/code&gt;来编写&lt;strong&gt;Gradle&lt;/strong&gt;构建脚本，具有高度可定制、更快的编译速度以及功能强大等特性。&lt;br /&gt;
&lt;strong&gt;Gradle&lt;/strong&gt;的核心为构建任何东西提供了一个基础架构，但是插件允许构建脚本作者花最少的努力完成任务，允许他们专注于构建什么，而不是如何构建。简单来说可以把&lt;strong&gt;Gradle&lt;/strong&gt;理解为是一个编程框架，我们只要遵循它的设计规则，利用它提供的API可以编写出各种各样的插件；在&lt;strong&gt;Gradle&lt;/strong&gt;中，每一个待编译的工程是一个&lt;strong&gt;Project&lt;/strong&gt;，每一个&lt;strong&gt;Project&lt;/strong&gt;在构建的时候都会包含一系列的&lt;strong&gt;Task&lt;/strong&gt;。一个Android项目的构建大致包含：Kotlin源码编译、Java源码编译、资源编译、JNI编译、Lint检查、混淆、打包、签名等等若干个Task任务。&lt;br /&gt;
&lt;strong&gt;Gradle&lt;/strong&gt;也是一个Java或者说JVM应用，这个应用的任务就是去完成构建期的工作，我们在编写&lt;strong&gt;Gradle&lt;/strong&gt;插件的时候其实和编写一个Android应用是非常类似的，只需要遵循&lt;strong&gt;Gradle&lt;/strong&gt;定义的规则以及了解它的一些生命周期即可（就和我们需要了解四大组件的生命周期一样）。&lt;br /&gt;
下面是一个&lt;strong&gt;Gradle&lt;/strong&gt;项目的结构：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;.
├── CustomPluginSample.iml
├── MyPlugin
│   ├── MyPlugin.iml
│   ├── build.gradle
│   ├── libs
│   └── src
├── app
│   ├── app.iml
│   ├── build
│   ├── build.gradle
│   ├── libs
│   ├── proguard-rules.pro
│   └── src
├── build.gradle
├── gradle
│   └── wrapper
├── gradle.properties
├── gradlew
├── gradlew.bat
├── local.properties
└── settings.gradle
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个项目包含&lt;strong&gt;MyPlugin&lt;/strong&gt;和&lt;strong&gt;app&lt;/strong&gt;以及&lt;strong&gt;CustomPluginSample&lt;/strong&gt;三个&lt;strong&gt;Project&lt;/strong&gt;（看目录下是否有build.gradle文件）&lt;br /&gt;
其中&lt;strong&gt;CustomPluginSample&lt;/strong&gt;是&lt;strong&gt;Root Project&lt;/strong&gt;，与其他&lt;strong&gt;Project&lt;/strong&gt;的区别是多了一个&lt;code&gt;settings.gradle&lt;/code&gt;文件，带有这个文件的&lt;strong&gt;Project&lt;/strong&gt;表明它是一个&lt;strong&gt;Multi Project&lt;/strong&gt;，这个文件是告诉&lt;strong&gt;Gradle&lt;/strong&gt;项目和子项目是如何构造的，我们来看下这个文件的内容：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;include &#39;:app&#39;, &#39;:MyPlugin&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;内容简单易懂，就是调用&lt;code&gt;include&lt;/code&gt;函数把&lt;strong&gt;app&lt;/strong&gt;和&lt;strong&gt;MyPlugin&lt;/strong&gt;包含到项目当中，而&lt;code&gt;build.gradle&lt;/code&gt;文件中则是配置当前&lt;strong&gt;Project&lt;/strong&gt;的构建脚本。&lt;br /&gt;
很显然，上面提到的两个文件是&lt;strong&gt;Gradle&lt;/strong&gt;约定好的规则，在&lt;strong&gt;Gradle&lt;/strong&gt;启动的时候会对项目目录进行扫描，找到这些文件，那现在第一个问题来了，这些文件是在什么时候被执行的呢？这就需要我们去了解&lt;strong&gt;Gradle&lt;/strong&gt;的生命周期了（是不是和刚学习Android开发的时候很像？）&lt;br /&gt;
&lt;img src=&#34;https://richardwrq.github.io/自定义Gradle插件/Gradle工作流程.png&#34; alt=&#34;Gradle工作流程&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Initialization&lt;/strong&gt;&lt;br /&gt;
Gradle支持单个和多个项目构建。在初始化阶段，Gradle确定哪些项目将参与构建，并为每个项目创建一个项目实例。&lt;code&gt;settings.gradle&lt;/code&gt;文件就是在这个时期执行的&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Configuration&lt;/strong&gt;&lt;br /&gt;
在此阶段将配置项目对象，作为构建的一部分的所有项目的构建脚本都被执行。&lt;code&gt;build.gradle&lt;/code&gt;文件被解析&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Execution&lt;/strong&gt;&lt;br /&gt;
Gradle确定要执行的任务的子集，这些任务是在&lt;strong&gt;Configuration&lt;/strong&gt;阶段创建和配置的。子集由传递给gradle命令和当前目录的任务名称参数决定。然后Gradle执行每一个被选择的任务。
我分别在每个&lt;code&gt;build.gradle&lt;/code&gt;以及&lt;code&gt;settings.gradle&lt;/code&gt;加了一些log输出的代码：&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;task MyPluginTask {
    System.println(&amp;quot;in project $project.name, build.gradle parsed&amp;quot;)
}


gradle.beforeProject {
    System.println(&amp;quot;------$project.name: beforeProject------&amp;quot;)
}

gradle.taskGraph.whenReady {
    System.println(&amp;quot;------$project.name: whenReady------&amp;quot;)
}

gradle.buildFinished {
    System.println(&amp;quot;------$project.name: buildFinished------&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在执行项目后输出日志内容如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;Executing tasks: [:app:generateDebugSources]

settings.gradle invoke
------settings.gradle: beforeProject------
in project CustomPluginSample, build.gradle parsed
------settings.gradle: beforeProject------
------CustomPluginSample: beforeProject------
in project app, build.gradle parsed
------settings.gradle: whenReady------
------CustomPluginSample: whenReady------
------app: whenReady------
:app:preBuild UP-TO-DATE
...中间省略
:app:processDebugResources UP-TO-DATE
:app:generateDebugSources UP-TO-DATE

BUILD SUCCESSFUL in 0s
13 actionable tasks: 13 up-to-date
------settings.gradle: buildFinished------
------CustomPluginSample: buildFinished------
------app: buildFinished------

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;很显然，&lt;strong&gt;Gradle&lt;/strong&gt;在解析完&lt;code&gt;settings.gradle&lt;/code&gt;后，每解析一个&lt;code&gt;build.gradle&lt;/code&gt;文件都会执行一遍上图的流程，而且调用&lt;code&gt;gradle.beforeProject&lt;/code&gt;等方法应该是将参数中的闭包添加到一个类似队列的数据结构，每次解析完一个&lt;code&gt;build.gradle&lt;/code&gt;文件后就会从这个数据结构中取出这些闭包从头开始执行一次。&lt;/p&gt;

&lt;h2 id=&#34;为什么&#34;&gt;为什么&lt;/h2&gt;

&lt;p&gt;在上面介绍完&lt;strong&gt;Gradle&lt;/strong&gt;是什么之后，我想*为什么要写Gradle插件*这个问题的答案也就呼之欲出了，前面说到&lt;strong&gt;Gradle&lt;/strong&gt;是一个编程框架，我们利用这个框架提供的API并遵循它制定的规则去实现我们想要的插件，比如构建Android应用的插件，编写自定义插件和编写一个供其他开发人员使用的第三方库的目的是一样的，都是把一些具备基本功能的API进一步封装，为开发人员提供更加方便、可以实现更复杂功能的API。&lt;/p&gt;

&lt;h2 id=&#34;怎么做&#34;&gt;怎么做&lt;/h2&gt;

&lt;h5 id=&#34;创建一个名为-myplugin-的module-在-myplugin-src-main-resources-meta-inf-gradle-plugins-目录下创建一个名为-org-example-greeting-properties-的文件&#34;&gt;创建一个名为&lt;strong&gt;MyPlugin&lt;/strong&gt;的Module，在&lt;strong&gt;MyPlugin/src/main/resources/META-INF/gradle-plugins/&lt;/strong&gt;目录下创建一个名为&lt;code&gt;org.example.greeting.properties&lt;/code&gt;的文件:&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;implementation-class=org.example.greeting.GreetingPlugin
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个文件是为了让&lt;strong&gt;Gradle&lt;/strong&gt;知道哪些类实现了&lt;code&gt;Plugin&lt;/code&gt;这个接口，而这个文件除了扩展名&lt;code&gt;.properties&lt;/code&gt;以外的名字将作为这个插件的唯一标识即ID。&lt;/p&gt;

&lt;h5 id=&#34;接下来我们看看greetingplugin的内容&#34;&gt;接下来我们看看GreetingPlugin的内容：&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class GreetingPlugin implements Plugin&amp;lt;Project&amp;gt; {

    @Override
    public void apply(Project project) {
        project.getPlugins().apply(SecondPlugin.class); //1

        GreetingPluginExtension extension = project.getExtensions().create(&amp;quot;greeting&amp;quot;, GreetingPluginExtension.class);//2

        project.getTasks().create(&amp;quot;hello&amp;quot;, Greeting.class, (task) -&amp;gt; {//3
            task.setMessage(&amp;quot;Hello&amp;quot;);
            task.setRecipient(&amp;quot;World&amp;quot;);
            task.doLast(task1 -&amp;gt; {
                System.out.println(&amp;quot;task message: &amp;quot; + task.getMessage() + &amp;quot;, recipient: &amp;quot; + task.getRecipient());
                System.out.println(&amp;quot;extension title: &amp;quot; + extension.title + &amp;quot;, message: &amp;quot; + extension.message);
            });
        });

    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;标注1处apply了另一个插件&lt;strong&gt;SecondPlugin&lt;/strong&gt;，这个类的apply方法将会被调用；&lt;br /&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;标注2处创建了一个名称为&lt;code&gt;greeting&lt;/code&gt;的&lt;strong&gt;extension&lt;/strong&gt;，对应的类是&lt;strong&gt;GreetingPluginExtension&lt;/strong&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class GreetingPluginExtension {
    String title = &amp;quot;default&amp;quot;;
    String message = &amp;quot;default&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;创建的这个&lt;strong&gt;extension&lt;/strong&gt;是什么东西呢？看一下&lt;strong&gt;build.gradle&lt;/strong&gt;文件的这句代码可能你就了解了：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;greeting {
    title = &#39;modify&#39;
    message = &#39;modify&#39;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们在使用很多第三方&lt;strong&gt;Gradle&lt;/strong&gt;插件的时候经常会碰到这样的代码，用户可以在这个闭包里面对其属性进行一些配置，这些配置就能够被插件获取到（有一个恶心的地方就是如果没有文档的话用户压根就不知道怎么去配置）。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;标注3处则创建了一个名为&lt;code&gt;hello&lt;/code&gt;的&lt;strong&gt;Task&lt;/strong&gt;，对应的类为&lt;strong&gt;Greeting&lt;/strong&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Greeting extends DefaultTask {
    
    private String message = &amp;quot;default&amp;quot;;
    private String recipient = &amp;quot;default&amp;quot;;
    
    public String getMessage() { return message; }
    public void setMessage(String message) { this.message = message; }
    
    public String getRecipient() { return recipient; }
    public void setRecipient(String recipient) { this.recipient = recipient; }
    
    @TaskAction
    void sayGreeting() {
        System.out.printf(&amp;quot;%s, %s!\n&amp;quot;, getMessage(), getRecipient());
    }
    
    @TaskAction
    void secondAction() {
        System.out.println(&amp;quot;this is second action&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Task&lt;/strong&gt;在&lt;strong&gt;Gradle&lt;/strong&gt;是一个很重要的类，上文提到插件就是负责定义各种&lt;strong&gt;Task&lt;/strong&gt;然后按照一定顺序执行最终完成整个构建流程，&lt;strong&gt;Gradle&lt;/strong&gt;提供了丰富的API来让我们对这些&lt;strong&gt;Task&lt;/strong&gt;添加额外的行为，以及建立它们之间的依赖关系。
​&lt;br /&gt;
####&lt;strong&gt;Task&lt;/strong&gt;的几种执行结果&lt;br /&gt;
当&lt;strong&gt;Gradle&lt;/strong&gt;执行一个任务的时候，它可以在控制台中用不同的结果标记任务。这些标签是基于任务是否有操作要执行，是否应该执行这些操作，是否执行了这些操作，以及这些操作是否做了任何更改。
​&lt;/p&gt;

&lt;h5 id=&#34;no-label-or-executed&#34;&gt;(no label) or EXECUTED&lt;/h5&gt;

&lt;p&gt;任务执行它所有的Actions&lt;br /&gt;
- 任务有actions且Gradle确定它们应该作为构建的一部分来执行&lt;br /&gt;
- 任务没有actions和依赖任务，或者所有依赖的任务已经被执行完毕&lt;/p&gt;

&lt;h5 id=&#34;up-to-date&#34;&gt;UP-TO-DATE&lt;/h5&gt;

&lt;p&gt;任务的输出没有改变&lt;br /&gt;
- 任务有输入和输出，如果它们没有改变&lt;br /&gt;
- 任务没有actions，但是任务已经告知Gradle它没有改变它的输出
- 任务没有任何actions和依赖任务，但它所有的依赖任务都是up-to-date, skipped或者from cache结果
- 任务没有actions和依赖任务&lt;/p&gt;

&lt;h5 id=&#34;from-cache&#34;&gt;FROM-CACHE&lt;/h5&gt;

&lt;p&gt;任务的输出可以从上一次执行缓存中找到（已开启构建缓存）&lt;/p&gt;

&lt;h5 id=&#34;skipped&#34;&gt;SKIPPED&lt;/h5&gt;

&lt;p&gt;任务不执行它的actions&lt;br /&gt;
- 任务被显示的排除在命令行之外
- 任务调用了&lt;code&gt;onlyif&lt;/code&gt;方法，只有在这个方法返回true的时候任务的actions才会被执行&lt;/p&gt;

&lt;h5 id=&#34;no-source&#34;&gt;NO-SOURCE&lt;/h5&gt;

&lt;p&gt;任务不需要执行它的actions，任务有输入和输出，但是没有&lt;code&gt;sources&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;更详细的内容参考&lt;a href=&#34;https://docs.gradle.org/4.10-rc-2/userguide/more_about_tasks.html&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://docs.gradle.org/4.10-rc-2/userguide/more_about_tasks.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;现在我们已经创建了一个简单的&lt;strong&gt;Plugin&lt;/strong&gt;，要怎么去应用它呢？官方文档的教程里面是让我们上传到仓库中，然后通过唯一ID去引入我们的自定义插件，但是这样对于我们只是写一个简单的demo来说太麻烦了，所以我找到一个简单的方法可以让我们比较方便的在本地去调试我们的自定义插件。&lt;br /&gt;
首先将项目编译完成，可以在&lt;strong&gt;GreetingPlugin/build/libs&lt;/strong&gt;目录下找到编译出来的jar包，将其拷贝到任意目录（我这里将它拷贝到&lt;strong&gt;GreetingPlugin/libs&lt;/strong&gt;目录），然后在项目跟目录的&lt;code&gt;build.gradle&lt;/code&gt;加入如下代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;buildscript {
    repositories {
        google()
        jcenter()
    }
    dependencies {
        classpath fileTree(include: [&#39;*.jar&#39;], dir: &#39;GreetingPlugin/libs/&#39;)
        classpath files(&#39;GreetingPlugin/libs/GreetingPlugin.jar&#39;)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后在需要引入插件的&lt;code&gt;build.gradle&lt;/code&gt;文件加入下面的代码即可&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;apply plugin: GreetingPlugin
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Android组件化之路</title>
      <link>https://richardwrq.github.io/2018/android%E7%BB%84%E4%BB%B6%E5%8C%96%E4%B9%8B%E8%B7%AF/</link>
      <pubDate>Fri, 21 Dec 2018 14:20:24 +0800</pubDate>
      
      <guid>https://richardwrq.github.io/2018/android%E7%BB%84%E4%BB%B6%E5%8C%96%E4%B9%8B%E8%B7%AF/</guid>
      <description>

&lt;h2 id=&#34;android组件化之路&#34;&gt;Android组件化之路&lt;/h2&gt;

&lt;p&gt;首先先分清楚两个概念：&lt;/p&gt;

&lt;h3 id=&#34;模块化&#34;&gt;模块化&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Modular_programming&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;模块化编程&lt;/a&gt;是将一个程序按照功能拆分成相互独立的若干模块，它强调将程序的&lt;strong&gt;功能&lt;/strong&gt;分离成独立的、可替换的模块。每个模块内只有与其相关功能的内容。&lt;/p&gt;

&lt;p&gt;模块化编程和结构化编程与面向对象编程是密切相关的，它们的目的都是将大型软件程序划分成一个个更小的部分。模块化编程的粒度会更“粗”一些。在Java9中也在编译器层面提供了模块化的支持：&lt;a href=&#34;https://en.wikipedia.org/wiki/Java_Platform_Module_System&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;Java Platform Module System&lt;/a&gt; 。&lt;/p&gt;

&lt;p&gt;组件是一个类似的概念，但通常指更高的级别；组件是整个系统的一部分，而模块是单个程序的一部分。“模块”一词因语言而有很大差异；在Python中，它非常小，每个文件都是一个模块，而在Java 9中，它是非常大的，其中模块是包的集合，包又是文件的集合。&lt;/p&gt;

&lt;p&gt;在面向对象编程中，通常使用接口作为模块间通信的桥梁，也就是基于接口的编程。&lt;/p&gt;

&lt;h3 id=&#34;组件化&#34;&gt;组件化&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Component-based_software_engineering&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;组件化开发&lt;/a&gt;是软件工程的一个分支，它强调对给定软件系统中广泛可用的功能进行分割。基于可重用的目的将一个大的软件系统拆分成多个独立的组件，减少系统耦合度。&lt;/p&gt;

&lt;p&gt;组件化开发中认为组件作为系统的一部分，是可独立运行的服务，维基百科中举了一个例子：在web服务中，有一种面向服务的架构设计&amp;ndash;&lt;a href=&#34;https://en.wikipedia.org/wiki/Service-oriented_architecture&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;service-oriented architectures&lt;/a&gt; (SOA)，这种架构设计从业务角度出发，利用企业现有的各种软件体系，重新整合并构建起一套新的软件架构。这套软件架构可以随着业务的变化，随时灵活地结合现有服务，组成一个新的软件。增加应用系统的灵活性。&lt;/p&gt;

&lt;p&gt;组件可以产生或者消费事件，也可以应用于事件驱动架构。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;组件之间通过接口进行通信&lt;/li&gt;
&lt;li&gt;组件是可替换的，如果后续组件满足初始组件的需求（通过接口表示），则组件可以替换另一个组件（在设计时或运行时），因此可以用更新的版本或替代的版本替换组件，而不会破坏系统的运行。&lt;/li&gt;
&lt;li&gt;一个判断可替换组件的经验法则是：如果组件B至少提供了A提供的组件，并且使用的组件不超过A使用的组件，那么组件B可以立即替换组件A&lt;/li&gt;
&lt;li&gt;当组件直接与用户交互时，应该考虑基于组件的可用性测试。&lt;/li&gt;
&lt;li&gt;组件需要是完全文档化、全面测试、具有全面的输入效度检查的。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;模块化-or-组件化&#34;&gt;模块化 or 组件化&lt;/h3&gt;

&lt;p&gt;不管是模块化还是组件化，都不是一个新的设计思想，它们最早都是在20世纪60年代就已经被提出了，但是早期的移动应用由于相对简单，本身逻辑功能也不多，所以在移动端的应用反而没那么广泛。（虽然Java最开始的模块化是针对在移动和嵌入式设备上的应用设计的）。&lt;/p&gt;

&lt;p&gt;从上面的概述来看其实组件化跟模块化没有明显的区别；一个登录功能可以是一个模块也可以是一个组件，一个日期选择控件可以是一个模块，也可以是一个组件，因为不管是模块化还是组件化，它们都有一个共同的目标：将一个大的软件系统细化成一个个模块或者组件，都是为了重用和解耦。因此没有一个明确的界线去区分它们。&lt;/p&gt;

&lt;p&gt;网上很多文章对于&lt;strong&gt;组件&lt;/strong&gt;和&lt;strong&gt;模块&lt;/strong&gt;的定义也是不尽相同的，一些人认为组件的粒度更细，它只是具备单一功能与业务无关的组件，比如一个日历选择控件就认为是一个&lt;strong&gt;组件&lt;/strong&gt;。而&lt;strong&gt;模块&lt;/strong&gt;他们认为就是&lt;strong&gt;业务模块&lt;/strong&gt;，顾名思义，就是按业务划分而成的模块。而另一部分人则相反。&lt;/p&gt;

&lt;p&gt;在维基百科对模块化的解释中有这么一句：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;A component is a similar concept, but typically refers to a higher level; a component is a piece of a whole system, while a module is a piece of an individual program&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;也就是认为&lt;strong&gt;组件&lt;/strong&gt;粒度较&lt;strong&gt;模块&lt;/strong&gt;要更大，所以本文对&lt;strong&gt;组件&lt;/strong&gt;和&lt;strong&gt;模块&lt;/strong&gt;做出以下定义：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;组件&lt;/strong&gt;：侧重于业务，可编译成单独的app，一般只负责单一业务，具备自身的生命周期（通常包含Android四大组件的一个或多个，所以称之为组件也更加贴切）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;模块&lt;/strong&gt;：侧重于功能，与业务无关，比如自定义控件、网络请求库、图片加载库等&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;而从Android Studio推出之后，我们在开发项目时也会有意识的将一些可重用的代码逻辑抽离成一个个的&lt;strong&gt;Module&lt;/strong&gt;，这也就是模块化开发的雏形。当然，组件化开发也不是就尽善尽美的，下面列举了它的一些优缺点：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;优点：&lt;/strong&gt;一个复杂的系统可以由一个个组件集合而成，甚至于不同的组合可以构建出不同的系统。每个组件有独立的版本，可独立编译、打包，大大提高了系统的灵活性以及开发人员的开发效率。应用的更新可以精细到组件，组件的升级替换不会影响到其它组件，也不会受其它组件的限制。&lt;/p&gt;

&lt;p&gt;基于组件化架构设计的应用比传统的“单片”设计可重用性高得多，因为这些组件可以在其他项目中重用，而且开发人员无需了解整个应用，可以只专注于分配给他们的较小的任务，提高开发效率。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;缺点：&lt;/strong&gt;组件化的实施对开发人员和团队管理人员提出了更高水平的要求，项目管理难度更大。组件间如何进行通信也是需要慎重考虑的。万事开头难，在对一个项目进行组件化分解时就好像庖丁解牛一般，你需要了解项目的&lt;strong&gt;“肌理筋骨”&lt;/strong&gt;，才知道从何处下&lt;strong&gt;“刀”&lt;/strong&gt;，才能更轻易的去分解项目，这就要求架构师对于项目的整体需求了如指掌。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;下面就来谈谈我的&lt;strong&gt;组件化&lt;/strong&gt;之路。。。&lt;/p&gt;

&lt;p&gt;首先我负责的项目类似于一个远程控制应用，它与服务器建立Socket连接，接收服务器发送过来的指令，针对这些指令对当前Android设备执行关机、安装应用等操作。应用本身也会收集一些设备信息如应用运行日志，使用时长等，在某个指定的时间点上传至服务器。理想的组件间依赖关系是这样的：
&lt;img src=&#34;https://richardwrq.github.io/组件化之路/组件化架构.jpg&#34; alt=&#34;组件化架构&#34; /&gt;&lt;/p&gt;

&lt;p&gt;其中基础模块不能脱离主工程独立运行，组件之间不能直接依赖，组件间通信方式可以是接口也可以是事件总线。团队中的开发人员只需要关注自身负责的组件（在开发模式下各组件会转化为可单独运行的App，说白了就是在&lt;code&gt;build.gradle&lt;/code&gt;文件中将&lt;code&gt;apply plugin: &#39;com.android.library&#39;&lt;/code&gt;改为&lt;code&gt;apply plugin: &#39;com.android.application&#39;&lt;/code&gt;，网上有很多相关资料，在此就不赘述了）。&lt;/p&gt;

&lt;p&gt;现在来了个开发需求需要改动组件&lt;code&gt;Component1&lt;/code&gt;内部的逻辑，团队中的小A是负责该组件的开发人员，在接到需求后，小A啪啪啪一顿猛如虎的操作完成需求后，对该组件进行单元测试，检查组件输入输出，测试通过后提交代码，审核通过后构建平台构建、打包、发布，整个过程完全没有“惊动”其他组件，Perfect！&lt;/p&gt;

&lt;p&gt;然而现实是残酷的。。&lt;/p&gt;

&lt;p&gt;由于组件间不可能完全不通信，所以现实情况组件之间的依赖关系有可能是这样的：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://richardwrq.github.io/组件化之路/现实情况依赖关系.jpg&#34; alt=&#34;现实情况下的依赖关系&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;对比上图，组件之间显得更加“亲密无间”了，而且这还不是糟糕的情况，当组件越来越多，各种相互依赖，循坏依赖的问题会让你痛不欲生。&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;因为组件之间不可避免的存在需要通信的情况，比如 &lt;code&gt;Component1&lt;/code&gt;需要调用&lt;code&gt;Component2&lt;/code&gt;的方法一般情况下我们都是直接通过类名或对象引用的方式去调用相应的方法。但是这种通信方式正是导致组件之间高度耦合的罪魁祸首，所以必须杜绝这种通信方式。&lt;/p&gt;

&lt;p&gt;那么问题来了，怎么做到既能让组件间通信又高度解耦呢？这就需要用到文章开头提到的&lt;strong&gt;面向接口编程&lt;/strong&gt;思想和&lt;strong&gt;依赖注入&lt;/strong&gt;（或者叫依赖查找）技术。举个🌰：&lt;/p&gt;

&lt;p&gt;组件A中的&lt;code&gt;Foo1&lt;/code&gt;类依赖组件B&lt;code&gt;Foo2&lt;/code&gt;类中的&lt;code&gt;bar&lt;/code&gt;方法，一种比较low的实现方式是：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//ComponentA
class Foo1 {
    private Foo2 mFoo2;
    public void main() {
        mFoo2 = new Foo2();
        mFoo2.bar();
    }
}

//ComponentB
class Foo2 {
    public void bar() {
        //nop
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这种实现方式违反了&lt;a href=&#34;https://baike.baidu.com/item/%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE%E5%8E%9F%E5%88%99/6189149&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;控制反转&lt;/a&gt;设计原则，耦合度高，假如这时需求变更了，需要使用组件C的&lt;code&gt;Foo3&lt;/code&gt;类中的&lt;code&gt;bar()&lt;/code&gt;方法去替换原来的实现，那这下乐子就大了。&lt;/p&gt;

&lt;p&gt;而通过面向接口编程以及&lt;strong&gt;依赖注入&lt;/strong&gt;技术我们能很好的遵循控制反转设计原则：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//Common Component
interface IBar {
    void bar()
}

//ComponentA
class Foo1 {
    private IBar mBar;
    
    public void main() {
        if (mBar != null) {
            mBar.bar();
        }
    }
    
    public void setBar(IBar bar) {
        mBar = bar;
    }
}

//ComponentB
class Foo2 implements IBar {
    
    @Override
    public void bar() {
        //nop
    }
}

//ComponentC
class Foo3 implements IBar {
    
    @Override
    public void bar() {
        //nop
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这就是经典的实现了控制反转的示例代码，&lt;code&gt;Foo1&lt;/code&gt;类只知道自己需要一个实现了&lt;code&gt;IBar&lt;/code&gt;接口的实例，然后调用接口的&lt;code&gt;bar()&lt;/code&gt;方法，至于是谁去实现的这个接口，不好意思，它压根不关心。&lt;/p&gt;

&lt;p&gt;虽然你&lt;code&gt;Foo1&lt;/code&gt;类是舒服了，把依赖关系交给外部去解决了，但是总要有人去负责这部分的工作吧。这时候依赖注入容器（IOC容器）就登场了，如果对web开发有所了解的同学肯定不会感到陌生，&lt;code&gt;Spring&lt;/code&gt;就是一个IOC容器，这个容器把依赖查找，类实例化（其实就是根据类的路径名称通过反射进行实例化）这些脏活累活揽在身上，这样既实现了控制反转又极大提高了应用的灵活性和可维护性。&lt;/p&gt;

&lt;p&gt;正因为依赖注入能有效地降低代码之间的耦合度，所以基于依赖注入实现的&lt;strong&gt;组件化框架&lt;/strong&gt;（路由框架）也就应运而生了，目前主流的Android组件化框架有&lt;a href=&#34;https://github.com/alibaba/ARouter&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;ARouter&lt;/a&gt;、&lt;a href=&#34;https://github.com/luckybilly/CC&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;CC&lt;/a&gt;、&lt;a href=&#34;https://github.com/luojilab/DDComponentForAndroid&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;DDComponentForAndroid&lt;/a&gt;、&lt;a href=&#34;https://github.com/mzule/ActivityRouter&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;ActivityRouter&lt;/a&gt;等等，我自己也使用&lt;code&gt;Kotlin&lt;/code&gt;基于&lt;code&gt;kapt&lt;/code&gt;技术实现了一个路由框架&lt;a href=&#34;https://github.com/richardwrq/KRouter&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;KRouter&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;虽然相关的框架有很多，但是它们实现原理不外乎两种：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;一种是将分布在各个组件的类按照一定的规则在内部生成映射表，这个映射表的数据结构通常是一个Map，Key是一个字符串，Value是一个类或者是类的路径名称（用于通过反射进行类的实例化）。通俗来说就是类的查找，这种实现方式要求调用方和被调用方都持有接口类，通常这些共同持有的接口类会被定义在一个&lt;code&gt;Common&lt;/code&gt;基础模块中，而且在运行时这些相互通信的组件必须打包到同一个APK中。这种实现方式导致无法真正实现代码隔离（需要通信的两个组件仍然是存在依赖关系的），基于这种原理实现的组件化架构“自约束能力”很弱，因为无法约束开发人员通过直接引用的方式进行通信的行为，虽然一开始设计人员想的很美好，但是开发人员在实现时做出来的产品却不是那样，因为“自约束能力”弱的架构设计是通过“编码规范”、“测试驱动”甚至是“人员熟练度”来保证开发人员实现的代码符合设计人员的设计初衷，而且这种架构也无法保证后续接手维护项目的开发人员能够贯彻原本的设计思想，随着时间推移，项目往越来越糟糕的方向演进（解决这个问题最好的方案就是从编译器层面进行约束，也就是把问题拦截在编码阶段，然而Java9才支持模块化开发，Android目前还处于支持部分Java8的特性的阶段，路还很长）。&lt;/li&gt;
&lt;li&gt;另一种方案是基于事件总线的方式实现组件之间的通信，不再是面向接口编程，而是面向通信协议编程，可以理解为组件间的调用类似http请求。这些框架会在内部建立跨进程通信的连接（也就是事件总线），这条事件总线负责分发路由请求以及返回执行结果。这种实现方式的好处是真正可以实现代码隔离，组件可以运行在独立的进程中，但是只支持基本类型参数的转发。实现跨进程通信有很多方案，比如Android原生的四大组件、Socket、FileObserver、MemoryFile、基于AIDL的Messager等等，使用Android原生的好处是安全性方面的工作由Android帮我们完成了，而使用Socket则需要自己实现加密Socket。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;第一种方案适合小型的项目，因为这些项目通常都是单进程的，虽然这样设计的架构“自约束能力”弱，但是目前大多数Android项目团队开发人数也不会太多，所以管理难度较小，而第二种实现方案则更适合跨进程组件化的项目（组件一般运行在独立的进程中甚至一个组件就是一个APP）。&lt;/p&gt;

&lt;p&gt;在我看来Android的组件化是存在3个阶段的，第一个是从单工程项目过度到多模块的阶段；第二个是从多模块过度到多组件的阶段；第三个就是多组件独立进程的阶段。而目前大多数应用其实都是在第二个阶段或者介于第二和第三个阶段之间，所以对于这样的项目，选择一个既支持类查找方式，又支持事件总线的组件化框架是最合适的（这也是一开始设计&lt;strong&gt;KRouter&lt;/strong&gt;想要达到的效果，虽然目前暂时不支持跨进程组件。。。）&lt;/p&gt;

&lt;p&gt;在项目实施组件化过程中，其实真正耗费时间、精力的不是编码，而是一开始组件的划分以及组件单元测试的代码的编写。有可能因为一开始对业务的不熟悉，导致后期开发时发现组件划分的不够准确，需要加以调整；或者是对接口抽象的不够好，导致维护时频繁修改接口；还有可能在编写单元测试时觉得枯燥乏味而选择放弃。我们不能因为遇到这些困难就半途而废，或者是质疑自己的架构设计能力，没有哪一个架构设计是放之四海皆准的，有可能一个项目的架构设计放在另一个项目中就显得不那么合适了。所以好的架构设计还需要设计人员“因地制宜”的对一个比较通用的架构骨架进行查漏补缺，最后使其与实际项目更加契合。&lt;/p&gt;

&lt;p&gt;祝大家都能成为一个优秀的架构设计师。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>IntelliJ IDEA/Android Studio插件开发入门指南</title>
      <link>https://richardwrq.github.io/2018/ideaplugin/</link>
      <pubDate>Wed, 21 Nov 2018 15:13:22 +0800</pubDate>
      
      <guid>https://richardwrq.github.io/2018/ideaplugin/</guid>
      <description>

&lt;p&gt;基于IntelliJ平台的产品都可以通过添加插件来丰富其原有的功能，JetBrains团队也我们提供了丰富的API来进行插件开发，所有的插件都可以在&lt;a href=&#34;https://plugins.jetbrains.com/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;JetBrains Plugin Repository&lt;/a&gt;找到。常见的插件类型有：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;自定义语言支持（如Java、Kotlin）&lt;/li&gt;
&lt;li&gt;框架集成&lt;/li&gt;
&lt;li&gt;工具集成&lt;/li&gt;
&lt;li&gt;用户界面插件&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这些类型插件的介绍以及功能就不一一细说了，&lt;a href=&#34;http://www.jetbrains.org/intellij/sdk/docs/basics/getting_started.html&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;官网&lt;/a&gt;也有比较详细的介绍。
简单来说，IDEA也好Android Studio也好（以下统一称为IDE），它们为插件提供了运行环境，通过各种插件的配合来实现不同的功能。下面就先介绍开发IDEA插件前需要哪些准备。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.jetbrains.com/idea/?fromMenu&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;安装IDEA&lt;/a&gt;，如果想在开发插件的过程中进行Debug，那么还需要把IDEA的源码下载下来(&lt;a href=&#34;https://github.com/JetBrains/intellij-community&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;Github源码地址&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;配置IntelliJ Platform SDK，也就是开发插件所需的SDK，类似开发Android应用时需要Android SDK，并且插件都是运行在JVM上的，所以也需要配置JDK的路径&lt;/li&gt;
&lt;li&gt;指定&lt;strong&gt;Sandbox Home&lt;/strong&gt;目录，&lt;strong&gt;Sandbox Home&lt;/strong&gt;目录用于存放插件项目实例的一些配置文件。在macOS系统中默认存放路径是&lt;code&gt;/Users/{用户名}/Library/Caches/IdeaIC2018.2/plugins-sandbox&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;配置SDK，如果你把IDEA源码也下载了，那么还需要配置一下源码的路径
&lt;img src=&#34;https://richardwrq.github.io/IDEAPlugin/添加SDK.jpg&#34; alt=&#34;添加SDK&#34; /&gt;
&lt;img src=&#34;https://richardwrq.github.io/IDEAPlugin/选择源码路径.jpg&#34; alt=&#34;添加源码&#34; /&gt;&lt;/p&gt;

&lt;p&gt;环境搭建好了，那么接下来我们就创建一个简易的插件工程，依次点击&lt;code&gt;File-&amp;gt;New-&amp;gt;Project&lt;/code&gt;然后在弹出框左栏选择&lt;code&gt;Gradle&lt;/code&gt;，然后在右侧一栏勾选&lt;code&gt;IntelliJ Platform Plugin&lt;/code&gt;（如果想要使用Kotlin进行开发就把&lt;code&gt;Kotlin&lt;/code&gt;那一项也勾选上）
&lt;img src=&#34;https://richardwrq.github.io/IDEAPlugin/新建插件项目.jpg&#34; alt=&#34;新建插件&#34; /&gt;
项目创建好后长这样：
&lt;img src=&#34;https://richardwrq.github.io/IDEAPlugin/项目结构.jpg&#34; alt=&#34;项目结构&#34; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;创建action&#34;&gt;创建Action&lt;/h1&gt;

&lt;p&gt;插件可以自定义IDE的UI，在菜单或工具栏中新加入一个Item。SDK提供了一个类&lt;code&gt;AnAction&lt;/code&gt;，这个类的&lt;code&gt;actionPerformed&lt;/code&gt;方法在你每次在菜单栏中选中或在工具栏中点击对应项时都会被调用。创建一个&lt;strong&gt;Action&lt;/strong&gt;只需要两步：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;定义派生于AnAction的类&lt;/li&gt;
&lt;li&gt;注册Action&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;当然你也可以定义一组派生于AnAction的类&lt;/code&gt;&lt;/p&gt;

&lt;h1 id=&#34;定义action&#34;&gt;定义Action&lt;/h1&gt;

&lt;p&gt;下面的代码是我仿照官方例子定义的一个Action，只是把Java改成了Kotlin实现&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Kotlin&#34;&gt;class TextBoxes : AnAction(&amp;quot;Text _Boxes&amp;quot;) {

    override fun actionPerformed(e: AnActionEvent) {
        val project = e.getData(PlatformDataKeys.PROJECT)//这个Project是不是很熟悉？它其实跟Gradle中的Project意义是一样的
        val txt = Messages.showInputDialog(project, &amp;quot;What is your name?&amp;quot;, &amp;quot;Input your name&amp;quot;, Messages.getQuestionIcon())
        Messages.showMessageDialog(project, &amp;quot;Hello, $txt!\\n I am glad to see you.&amp;quot;, &amp;quot;Information&amp;quot;, Messages.getInformationIcon())//这两段代码其实很简单，都不用解释了
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;注册action&#34;&gt;注册Action&lt;/h1&gt;

&lt;p&gt;定义好&lt;strong&gt;Action&lt;/strong&gt;之后当然就需要告知IDE你有哪些&lt;strong&gt;Action&lt;/strong&gt;啦，所以就需要对这些&lt;strong&gt;Action&lt;/strong&gt;进行注册，注册的方式有两种（是不是似曾相识的感觉？）。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在&lt;code&gt;plugin.xml&lt;/code&gt;文件的&lt;code&gt;&amp;lt;actions&amp;gt;&lt;/code&gt;标签中进行注册&lt;/li&gt;
&lt;li&gt;在代码中进行注册&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;在plugin-xml文件中进行注册&#34;&gt;在plugin.xml文件中进行注册&lt;/h1&gt;

&lt;p&gt;跟Android开发中在&lt;code&gt;AndroidManifest.xml&lt;/code&gt;文件中注册组件非常相像，我们只需要按照&lt;strong&gt;IntelliJ&lt;/strong&gt;平台的规范在&lt;code&gt;plugin.xml&lt;/code&gt;文件的&lt;code&gt;&amp;lt;actions&amp;gt;&lt;/code&gt;部分内容进行修改：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;actions&amp;gt;
  &amp;lt;group id=&amp;quot;MyPlugin.SampleMenu&amp;quot; text=&amp;quot;_Sample Menu&amp;quot; description=&amp;quot;Sample menu&amp;quot;&amp;gt;
    &amp;lt;add-to-group group-id=&amp;quot;MainMenu&amp;quot; anchor=&amp;quot;last&amp;quot;  /&amp;gt;
       &amp;lt;!--把这组Action加到&amp;quot;MainMenu&amp;quot;中--&amp;gt;
       &amp;lt;action id=&amp;quot;Myplugin.Textboxes&amp;quot; class=&amp;quot;Mypackage.TextBoxes&amp;quot; text=&amp;quot;Text _Boxes&amp;quot; description=&amp;quot;A test menu item&amp;quot; /&amp;gt;
  &amp;lt;/group&amp;gt;
&amp;lt;/actions&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面对&lt;code&gt;plugin.xml&lt;/code&gt;的规范做一些介绍：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!-- Actions --&amp;gt;
    &amp;lt;actions&amp;gt;
    &amp;lt;!-- &amp;lt;action&amp;gt;对Action进行注册，
         &amp;quot;id&amp;quot;定义了这个Action的唯一识别id，
         &amp;quot;class&amp;quot;用于指定该Action对应类的全路径，
         &amp;quot;text&amp;quot;定义这个Action在菜单栏或者工具栏中显示的文本，前面加_表示在该字符下加下划线，
         &amp;quot;use-shortcut-of&amp;quot; 可选项 指定使用和某一个Action一样的快捷键
         &amp;quot;description&amp;quot; 可选项 对Action的描述（当你的鼠标指针停留在该item时就会显示该内容）
         &amp;quot;icon&amp;quot;没啥好说的--&amp;gt;
    &amp;lt;action id=&amp;quot;VssIntegration.GarbageCollection&amp;quot; class=&amp;quot;com.foo.impl.CollectGarbage&amp;quot; text=&amp;quot;Collect _Garbage&amp;quot; description=&amp;quot;Run garbage collector&amp;quot; icon=&amp;quot;icons/garbage.png&amp;quot;&amp;gt;
        &amp;lt;!-- &amp;lt;add-to-group&amp;gt;节点表示指定Action被加入到已存在的一个组中，
             &amp;quot;group-id&amp;quot;表示加入的组的id，
             &amp;quot;anchor&amp;quot;指定Action相对于组中其他Action的位置，可以指定的值有&amp;quot;first&amp;quot;, &amp;quot;last&amp;quot;, &amp;quot;before&amp;quot;, &amp;quot;after&amp;quot;
             &amp;quot;relative-to-action&amp;quot;如果把&amp;quot;anchor&amp;quot;的值设置为&amp;quot;before&amp;quot;或者&amp;quot;after&amp;quot;时，必须为该属性赋值，表示相对于某一个Action的位置--&amp;gt;
        &amp;lt;add-to-group group-id=&amp;quot;ToolsMenu&amp;quot; relative-to-action=&amp;quot;GenerateJavadoc&amp;quot; anchor=&amp;quot;after&amp;quot;/&amp;gt;
        &amp;lt;!-- &amp;lt;keyboard-shortcut&amp;gt;指定Action的快捷键
             &amp;quot;second-keystroke&amp;quot;指定Action次选快捷键
             &amp;quot;keymap&amp;quot;指定Action的快捷键映射到哪一个系统中，可以设定的值作为常量定义在
             com.intellij.openapi.keymap.KeymapManager类中--&amp;gt;
        &amp;lt;keyboard-shortcut first-keystroke=&amp;quot;control alt G&amp;quot; second-keystroke=&amp;quot;C&amp;quot; keymap=&amp;quot;$default&amp;quot;/&amp;gt;
        &amp;lt;!-- 指定鼠标快捷键 --&amp;gt;
        &amp;lt;mouse-shortcut keystroke=&amp;quot;control button3 doubleClick&amp;quot; keymap=&amp;quot;$default&amp;quot;/&amp;gt;
    &amp;lt;/action&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;使用代码进行注册&#34;&gt;使用代码进行注册&lt;/h1&gt;

&lt;p&gt;使用代码注册其实也没什么少介绍的，贴一段官方代码大家就大致了解了，就是调用相应的api去做一些配置&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;public class MyPluginRegistration implements ApplicationComponent {
  // Returns the component name (any unique string value).
  @NotNull public String getComponentName() {
    return &amp;quot;MyPlugin&amp;quot;;
  }


  // If you register the MyPluginRegistration class in the &amp;lt;application-components&amp;gt; section of
  // the plugin.xml file, this method is called on IDEA start-up.
  public void initComponent() {
    ActionManager am = ActionManager.getInstance();
    TextBoxes action = new TextBoxes();

    // Passes an instance of your custom TextBoxes class to the registerAction method of the ActionManager class.
    am.registerAction(&amp;quot;MyPluginAction&amp;quot;, action);

    // Gets an instance of the WindowMenu action group.
    DefaultActionGroup windowM = (DefaultActionGroup) am.getAction(&amp;quot;WindowMenu&amp;quot;);

    // Adds a separator and a new menu command to the WindowMenu group on the main menu.
    windowM.addSeparator();
    windowM.add(action);
  }

  // Disposes system resources.
  public void disposeComponent() {
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面两种注册方式是不是都感觉挺麻烦，在AS中我们创建一个Activity的时候可以通过&lt;code&gt;File-&amp;gt;New-&amp;gt;Activity&lt;/code&gt;来帮我们创建一个Activity，并且已经帮我们注册到&lt;code&gt;AndroidManifest.xml&lt;/code&gt;中，甚至是布局文件也创建好了，那么IDEA能做到吗？答案是肯定的，而且步骤也大同小异：
&lt;img src=&#34;https://richardwrq.github.io/IDEAPlugin/快速创建Action.jpg&#34; alt=&#34;快速创建Action&#34; /&gt;&lt;/p&gt;

&lt;p&gt;接下来我们点击运行或&lt;code&gt;Debug&lt;/code&gt;即可看到运行效果
&lt;img src=&#34;https://richardwrq.github.io/IDEAPlugin/运行效果1.jpg&#34; alt=&#34;运行效果1&#34; /&gt;
&lt;img src=&#34;https://richardwrq.github.io/IDEAPlugin/运行效果2.jpg&#34; alt=&#34;运行效果2&#34; /&gt;
&lt;img src=&#34;https://richardwrq.github.io/IDEAPlugin/运行效果3.jpg&#34; alt=&#34;运行效果3&#34; /&gt;&lt;/p&gt;

&lt;p&gt;到这里相信你也了解了怎么样去创建并运行一个简单的IDEA插件了，整个过程是不是和开发一个Android应用非常相像呢，其实都可以把他们看成是开发一个带UI界面的JVM应用程序，当你开发好一个插件之后，需要将其上传到远程仓库中以供他人使用，整个流程和发布一个第三方库也是大同小异。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>注解处理器Annotation Processor中判断Java或Kotlin类</title>
      <link>https://richardwrq.github.io/2018/judgejavaorkt/</link>
      <pubDate>Fri, 27 Apr 2018 19:45:50 +0800</pubDate>
      
      <guid>https://richardwrq.github.io/2018/judgejavaorkt/</guid>
      <description>&lt;p&gt;在Android Studio中，项目编译build之后kapt会在项目的&lt;code&gt;build/tmp/kapt3/stubs&lt;/code&gt;目录下会生成kotlin编写的类的Java“存根类”，在这些类的顶部我们可以看到有这样一个注解&lt;code&gt;@kotlin.Metadata(...)&lt;/code&gt;
 &lt;code&gt;@Metadata&lt;/code&gt;是 Kotlin 里比较特殊的一个注解。它记录了 Kotlin 代码元素的一些信息，比如 class 的可见性，function 的返回值，参数类型，property 的 lateinit，nullable 的属性等等。这些 Metadata 的信息由 kotlinc 生成，最终会以注解的形式存于 .class 文件。
所以要在注解处理器判断一个类是kotlin语言或者Java语言编写的我们可以通过判断该类是否有&lt;code&gt;@Metadata&lt;/code&gt;注解来区分：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;    /**
     * if true mean this class is java class
     */
    private fun isJavaFile(element: TypeElement): Boolean {
        val tmMetadata = mElements.getTypeElement(&amp;quot;kotlin.Metadata&amp;quot;).asType()
        return element.annotationMirrors.find { it.annotationType == tmMetadata } == null
    }
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>使用Kotlin打造Android路由框架-Krouter</title>
      <link>https://richardwrq.github.io/2018/krouter/</link>
      <pubDate>Fri, 27 Apr 2018 12:35:27 +0800</pubDate>
      
      <guid>https://richardwrq.github.io/2018/krouter/</guid>
      <description>

&lt;p&gt;&lt;strong&gt;KRouter&lt;/strong&gt;(&lt;a href=&#34;https://github.com/richardwrq/KRouter)路由框架借助gradle插件、[kapt](https://blog.jetbrains.com/kotlin/2015/05/kapt-annotation-processing-for-kotlin/)实现了依赖注入、为Android平台页面启动提供路由功能。&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://github.com/richardwrq/KRouter)路由框架借助gradle插件、[kapt](https://blog.jetbrains.com/kotlin/2015/05/kapt-annotation-processing-for-kotlin/)实现了依赖注入、为Android平台页面启动提供路由功能。&lt;/a&gt;
源码不复杂，在关键地方也有注释说明，建议打算或正在使用kapt+kotlinpoet遇到坑的同学可以fork一下项目，或许能找到你想要的答案，只要将整个流程了解清楚了，相信你自己也能撸一个轮子出来，目前许多开源框架&lt;code&gt;dagger&lt;/code&gt;、&lt;code&gt;butter knife&lt;/code&gt;、&lt;code&gt;greendao&lt;/code&gt;等实现原理都是一致的。
####从startActivity开始说起
在组件化开发的实践过程中，当我完成一个模块的开发后（比如说这个模块中有一个Activity或者Service供调用者调用），其他模块的开发者要启动我这个模块中的Activity的代码我们再熟悉不过了：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;    val intent = Intent(this, MainActivity::class.java)
    intent.putExtra(&amp;quot;param1&amp;quot;, &amp;quot;1&amp;quot;)
    intent.putExtra(&amp;quot;param2&amp;quot;, &amp;quot;2&amp;quot;)
    startActivity(intent)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然，其他模块的开发人员需要知道我们这个Activity的类名以及传入的参数对应的key值（上面的param1和param2），这时候我就想，在每一个需要启动这个页面的地方都存在着类似的样板代码，而且被启动的Activity在取出参数对属性进行赋值时的代码也比较繁琐，于是在网上查找相关资料了解到目前主流的路由框架（ARouter、Router等）都支持这些功能，秉着尽量不重复造轮子的观念我fork了ARouter项目，但是阅读源码后发现其暂时不支持Service的启动，而我负责的项目里面全是运行在后台的Service。。。紧接着也大概了解了一下其他一些框架，都存在一些不太满意的地方，考虑再三，干脆自己撸一个轮子出来好了。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;首先来看一段最简单的发起路由请求的代码(Java调用)：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;    KRouter.INSTANCE.create(&amp;quot;krouter/main/activity?test=32&amp;quot;)
                    .withFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP)
                    .withString(&amp;quot;test2&amp;quot;, &amp;quot;this is test2&amp;quot;)
                    .request();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中&lt;code&gt;krouter/main/activity?test=32&lt;/code&gt;为对应的路由路径，可以使用类似http请求的格式，在问号后紧接着的是请求参数，这些参数最终会自动包装在intent的extras中，也可以通过调用&lt;code&gt;with&lt;/code&gt;开头的函数来配置请求参数。
上面的代码执行后最终会启动一个Activity，准确来说是一个带有&lt;code&gt;@Route&lt;/code&gt;注解的Activity，它长这样：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;    @Route(path = &amp;quot;krouter/main/activity&amp;quot;)
    public class MainActivity extends Activity {
        ...
        @Override
        protected void onCreate(Bundle savedInstanceState) {
            super.onCreate(savedInstanceState);
            setContentView(R.layout.activity_main);
            getIntent().getIntExtra(&amp;quot;test&amp;quot;, -1);//这里可以获取到请求参数test
        }
        ...
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是一个最基本的功能，怎么样，看起来还不错吧？跟大部分路由框架的调用方式差不多。现在主流的路由框架是怎么做到的呢？下面就看我一一道来。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;在使用&lt;code&gt;KRouter&lt;/code&gt;的API前首先需要为一些类添加注解：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;/**
 * User: WuRuiqiang(263454190@qq.com)
 * Date: 18/1/2
 * Time: 上午10:53
 * Version: v1.0
 * Description：用于标记可路由的组件
 */
@Target(AnnotationTarget.CLASS)
@Retention(AnnotationRetention.SOURCE)
annotation class Route(
        /**
         * Path of route
         */
        val path: String,
        /**
         * PathPrefix of route
         */
        val pathPrefix: String = &amp;quot;&amp;quot;,
        /**
         * PathPattern of route
         */
        val pathPattern: String = &amp;quot;&amp;quot;,
        /**
         * Name of route
         */
        val name: String = &amp;quot;undefined&amp;quot;,
        /**
         * Priority of route
         */
        val priority: Int = -1)

/**
 * User: WuRuiqiang(263454190@qq.com)
 * Date: 18/1/2
 * Time: 上午10:53
 * Version: v1.0
 * Description：用于拦截路由的拦截器
 */
@Target(AnnotationTarget.CLASS)
@Retention(AnnotationRetention.SOURCE)
annotation class Interceptor(
        /**
         * Priority of interceptor
         */
        val priority: Int = -1,
        /**
         * Name of interceptor
         */
        val name: String = &amp;quot;DefaultInterceptor&amp;quot;)

/**
 * User: WuRuiqiang(263454190@qq.com)
 * Date: 18/1/2
 * Time: 上午10:53
 * Version: v1.0
 * Description：属性注入
 */
@Target(AnnotationTarget.FIELD)
@Retention(AnnotationRetention.SOURCE)
annotation class Inject(
        /**
         * Name of property
         */
        val name: String = &amp;quot;&amp;quot;,
        /**
         * If true, app will be throws NPE when value is null
         */
        val isRequired: Boolean = false,
        /**
         * Description of the field
         */
        val desc: String = &amp;quot;No desc.&amp;quot;)

/**
 * User: WuRuiqiang(263454190@qq.com)
 * Date: 18/1/2
 * Time: 上午10:53
 * Version: v1.0
 * Description：Provider
 */
@Target(AnnotationTarget.CLASS)
@Retention(AnnotationRetention.SOURCE)
annotation class Provider(/**
                           * Path of Provider
                           */
                          val value: String)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;被注解的元素的信息最终被保存在对应的数据类中：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;/**
 * User: WuRuiqiang(263454190@qq.com)
 * Date: 18/1/4
 * Time: 上午10:46
 * Version: v1.0
 * Description：Route元数据，用于存储被[com.github.richardwrq.krouter.annotation.Route]注解的类的信息
 */
data class RouteMetadata(
        /**
         * Type of Route
         */
        val routeType: RouteType = RouteType.UNKNOWN,
        /**
         * Priority of route
         */
        val priority: Int = -1,
        /**
         * Name of route
         */
        val name: String = &amp;quot;undefine&amp;quot;,
        /**
         * Path of route
         */
        val path: String = &amp;quot;&amp;quot;,
        /**
         * PathPrefix of route
         */
        val pathPrefix: String = &amp;quot;&amp;quot;,
        /**
         * PathPattern of route
         */
        val pathPattern: String = &amp;quot;&amp;quot;,
        /**
         * Class of route
         */
        val clazz: Class&amp;lt;*&amp;gt; = Any::class.java)
/**
 * User: WuRuiqiang(263454190@qq.com)
 * Date: 18/1/8
 * Time: 下午10:46
 * Version: v1.0
 * Description：Interceptor元数据，用于存储被[com.github.richardwrq.krouter.annotation.Interceptor]注解的类的信息
 */
data class InterceptorMetaData(
        /**
         * Priority of Interceptor
         */
        val priority: Int = -1,
        /**
         * Name of Interceptor
         */
        val name: String = &amp;quot;undefine&amp;quot;,
        /**
         * Class desc of Interceptor
         */
        val clazz: Class&amp;lt;*&amp;gt; = Any::class.java)

/**
 * User: WuRuiqiang(263454190@qq.com)
 * Date: 18/3/14
 * Time: 上午1:28
 * Version: v1.0
 * Description：Injector元数据，用于存储被[com.github.richardwrq.krouter.annotation.Inject]注解的类的信息
 */
data class InjectorMetaData(
        /**
         * if true, throw NPE when the filed is null
         */
        val isRequired: Boolean = false,
        /**
         * key
         */
        val key: String = &amp;quot;&amp;quot;,
        /**
         * field name
         */
        val fieldName: String = &amp;quot;&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中被&lt;strong&gt;@Route&lt;/strong&gt;注解的类是Android中的四大组件和Fragment或者它们的子类（目前尚不支持Broadcast以及ContentProvider），被&lt;strong&gt;@Route&lt;/strong&gt;注解的对象目前有3种处理方式：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;若被注解的类是Activity的子类，那么最终的处理方式是startActivity；&lt;/li&gt;
&lt;li&gt;若被注解的类是Service的子类，最终的处理方式有两种，也就  是Android中启动Service的两种方式，使用哪种启动方式取决于是否调用了&lt;code&gt;withServiceConn&lt;/code&gt;函数添加了ServiceConnection；&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;若被注解的类是Fragment的子类，最终的处理方式是调用无参构造函数构造出这个类的实例，并调用&lt;code&gt;setArguments(Bundle args)&lt;/code&gt;将请求参数传入Fragment的bundle中，最后返回该实例&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;被&lt;strong&gt;@Interceptor&lt;/strong&gt;注解的类需实现&lt;strong&gt;IRouteInterceptor&lt;/strong&gt;接口，这些类主要处理是否拦截路由的逻辑，比如某些需要登录才能启动的组件，就可以用到拦截器
&lt;strong&gt;@Inject&lt;/strong&gt;用于标记需要被注入的属性
被&lt;strong&gt;@Provider&lt;/strong&gt;注解的类最终可以调用&lt;code&gt;KRouter.getProvider(path: String)&lt;/code&gt;方法获取该类的对象，如果该类实现了&lt;strong&gt;IProvider&lt;/strong&gt;接口，那么&lt;code&gt;init(context: Context)&lt;/code&gt;方法将被调用
这些注解最终都不会被编译进class文件中，在编译时期这些注解会被收集起来最终交由不同的Annotation Processor去处理。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;KRouter&lt;/strong&gt;路由框架分为3个模块：
- &lt;strong&gt;KRouter-api&lt;/strong&gt;模块，作为SDK提供API供应用调用，调用&lt;strong&gt;KRouter-compiler&lt;/strong&gt;模块生成的类中的方法加载路由表，处理路由请求
- &lt;strong&gt;KRouter-compiler&lt;/strong&gt;模块，各种注解对应的Processor的集合，编译期运行，负责收集路由组件，并生成kotlin代码
- &lt;strong&gt;KRouter-gradle-plugin&lt;/strong&gt;模块，自定义gradle插件，在项目构建时期添加相关依赖以及相关参数的配置&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://upload-images.jianshu.io/upload_images/745509-d2b8cacc05798b3f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;各模块运行时期.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;#####KRouter-compiler
在介绍该模块之前如果有同学不知道&lt;strong&gt;Annotation Processor&lt;/strong&gt;的话建议先阅读 &lt;a href=&#34;http://blog.csdn.net/hj7jay/article/details/52180023&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;Annotation Processing-Tool详解&lt;/a&gt;， &lt;a href=&#34;http://blog.csdn.net/u013045971/article/details/53509237&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;一小时搞明白注解处理器（Annotation Processor Tool）&lt;/a&gt;这两篇文章，简单来说，APT就是&lt;code&gt;javac&lt;/code&gt;提供的一个插件，它会搜集被指定注解所注解的元素（类、方法或者属性），最终将搜集到的这些交给注解处理器&lt;strong&gt;Annotation Processor&lt;/strong&gt;进行处理，注解处理器通常会生成一些新的代码（推荐大名鼎鼎的square团队造的轮子&lt;strong&gt;&lt;a href=&#34;https://github.com/square/javapoet&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;javapoet&lt;/a&gt;&lt;/strong&gt;，这个开源库提供了非常友好的API让我们去生成Java代码），这些新生成的代码会与源码一起在同一个编译时期进行编译。
但是&lt;strong&gt;Annotation Processor&lt;/strong&gt;是&lt;code&gt;javac&lt;/code&gt;提供的一个插件，也就是说它只认识Java代码，它压根不知道kotlin是什么，所以如果是用kotlin编写的代码文件最终将会被&lt;code&gt;javac&lt;/code&gt;给忽略，所幸的是JetBrains在2015年就推出了&lt;a href=&#34;https://blog.jetbrains.com/kotlin/2015/05/kapt-annotation-processing-for-kotlin/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;kapt&lt;/a&gt;来解决这一问题。而且既然有javapoet，那square那么牛逼的团队肯定也会造一个生成kotlin代码的轮子吧，果不其然，在github一搜kotlinpoet，还真有，所以最终决定&lt;strong&gt;KRouter-compiler&lt;/strong&gt;模块使用&lt;strong&gt;kapt&lt;/strong&gt;+&lt;strong&gt;&lt;a href=&#34;https://github.com/square/kotlinpoet&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;kotlinpoet&lt;/a&gt;&lt;/strong&gt;来自动生成代码（kotlinpoet文档过于简单了，建议使用该库的同学通过它的测试用例或者参照Javapoet文档了解API的调用）。&lt;/p&gt;

&lt;p&gt;开头的例子中我们可以看到使用&lt;strong&gt;KRouter&lt;/strong&gt;启动一个Activity只需要知道该Activity的路径即可，并不需要像Android原生的启动方式一样传入&lt;code&gt;Class&amp;lt;*&amp;gt;&lt;/code&gt;或者&lt;code&gt;Class Name&lt;/code&gt;，那么&lt;strong&gt;KRouter&lt;/strong&gt;是怎么做到的呢？
原理很简单，&lt;strong&gt;KRouter-compiler&lt;/strong&gt;模块生了初始化&lt;code&gt;路由表&lt;/code&gt;的代码，这些&lt;code&gt;路由表&lt;/code&gt;内部其实就是一个个map，这些map以路径path作为key，数据类作为value（比如&lt;strong&gt;RouteMetadata&lt;/strong&gt;），SDK内部会通过path获取到数据类，像开头启动Activity的例子中，SDK就通过path获取到一个&lt;strong&gt;RouteMetadata&lt;/strong&gt;对象，在这个对象中取出被注解的类的&lt;code&gt;Class&amp;lt;*&amp;gt;&lt;/code&gt;，有了这个&lt;code&gt;Class&amp;lt;*&amp;gt;&lt;/code&gt;就可以完成启动Activity的操作。
接下来说说&lt;code&gt;路由表&lt;/code&gt;初始化代码生成之后是怎么被执行的，首先我定义了这样一些接口：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;/**
 * 加载路由
 *
 * @author: Wuruiqiang &amp;lt;a href=&amp;quot;mailto:263454190@qq.com&amp;quot;&amp;gt;Contact me.&amp;lt;/a&amp;gt;
 * @version: v1.0
 * @since: 18/1/4 下午6:38
 */
interface IRouteLoader {
    fun loadInto(map: MutableMap&amp;lt;String, RouteMetadata&amp;gt;)
}

/**
 * 加载拦截器
 *
 * @author: Wuruiqiang &amp;lt;a href=&amp;quot;mailto:263454190@qq.com&amp;quot;&amp;gt;Contact me.&amp;lt;/a&amp;gt;
 * @version: v1.0
 * @since: 18/1/5 上午9:12
 */
interface IInterceptorLoader {
    fun loadInto(map: TreeMap&amp;lt;Int, InterceptorMetaData&amp;gt;)
}

/**
 * 加载Provider
 *
 * @author: Wuruiqiang &amp;lt;a href=&amp;quot;mailto:263454190@qq.com&amp;quot;&amp;gt;Contact me.&amp;lt;/a&amp;gt;
 * @version: v1.0
 * @since: 18/1/5 上午9:12
 */
interface IProviderLoader {
    fun loadInto(map: MutableMap&amp;lt;String, Class&amp;lt;*&amp;gt;&amp;gt;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以&lt;strong&gt;@Route&lt;/strong&gt;注解为例，在&lt;strong&gt;KRouter-compiler&lt;/strong&gt;中定义了一个继承自&lt;strong&gt;AbstractProcessor&lt;/strong&gt;的类&lt;strong&gt;RouteProcessor&lt;/strong&gt;，在编译期间编译器会收集&lt;strong&gt;@Route&lt;/strong&gt;注解的元素的信息然后交由&lt;strong&gt;RouteProcessor&lt;/strong&gt;处理，&lt;strong&gt;RouteProcessor&lt;/strong&gt;会生成一个实现了&lt;strong&gt;IRouteLoader&lt;/strong&gt;接口的类，在&lt;code&gt;loadInto&lt;/code&gt;方法中把注解中的元数据与被注解的元素的部分信息存到&lt;strong&gt;RouteMetadata&lt;/strong&gt;对象，然后将注解的路径path作为key，&lt;strong&gt;RouteMetadata&lt;/strong&gt;对象作为value保存在一个map当中。生成的代码如下（项目build之后可以在&lt;code&gt;(module)/build/generated/source/kaptKotlin/(buildType)&lt;/code&gt;目录下找到这些自动生成的类）：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;/**
 *    ***************************************************
 *    * THIS CODE IS GENERATED BY KRouter, DO NOT EDIT. *
 *    ***************************************************
 */
class KRouter_RouteLoader_app : IRouteLoader {
    override fun loadInto(map: MutableMap&amp;lt;String, RouteMetadata&amp;gt;) {
        map[&amp;quot;krouter/sample/MainActivity&amp;quot;] = RouteMetadata(RouteType.ACTIVITY, -1, &amp;quot;undefined&amp;quot;, &amp;quot;krouter/sample/MainActivity&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;&amp;quot;, MainActivity::class.java)
        map[&amp;quot;myfragment&amp;quot;] = RouteMetadata(RouteType.FRAGMENT_V4, -1, &amp;quot;undefined&amp;quot;, &amp;quot;myfragment&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;&amp;quot;, MainActivity.MyFragment::class.java)
        map[&amp;quot;krouter/sample/fragment1&amp;quot;] = RouteMetadata(RouteType.FRAGMENT, -1, &amp;quot;undefined&amp;quot;, &amp;quot;krouter/sample/fragment1&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;&amp;quot;, Fragment1::class.java)
        map[&amp;quot;krouter/sample/fragment2&amp;quot;] = RouteMetadata(RouteType.FRAGMENT, -1, &amp;quot;undefined&amp;quot;, &amp;quot;krouter/sample/fragment2&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;&amp;quot;, Fragment2::class.java)
        map[&amp;quot;krouter/sample/Main2Activity&amp;quot;] = RouteMetadata(RouteType.ACTIVITY, -1, &amp;quot;undefined&amp;quot;, &amp;quot;krouter/sample/Main2Activity&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;&amp;quot;, Main2Activity::class.java)
        map[&amp;quot;krouter/sample/Main3Activity&amp;quot;] = RouteMetadata(RouteType.ACTIVITY, -1, &amp;quot;undefined&amp;quot;, &amp;quot;krouter/sample/Main3Activity&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;&amp;quot;, Main3Activity::class.java)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;代码生成之后，我们需要执行&lt;code&gt;loadInto&lt;/code&gt;方法才算是把数据存入到map中去，我们可以通过&lt;code&gt;Class.forName(ClassName).newInstance()&lt;/code&gt;获取该类实例，然后将其强制转换为&lt;strong&gt;IRouteLoader&lt;/strong&gt;类型，接着调用&lt;code&gt;loadInto&lt;/code&gt;方法传入map即可，现在问题来了，加载一个类我们需要知道这个类的路径和名称：&lt;code&gt;com.x.y.ClassA&lt;/code&gt;，但是SDK并不知道&lt;strong&gt;KRouter-compiler&lt;/strong&gt;会生成哪些类。
为此我准备了两种解决方案：
1. 类似&lt;code&gt;ARouter&lt;/code&gt;的做法，扫描所有dex文件，找出实现了&lt;code&gt;ARouter&lt;/code&gt;接口的类，然后将这些类的ClassName缓存至本地，下次应用启动时如果存在缓存且没有新增文件则读取缓存内容即可；
2. 第二种是生成的类及其路径遵循一定的规则，比如由&lt;strong&gt;RouteProcessor&lt;/strong&gt;生成的类路径规定为&lt;code&gt;com.github.richardwrq.krouter&lt;/code&gt;，类名规定以“KRouter_RouteLoader_”作为开头然后拼接上Module名称（以Module名称作为后缀是避免在不同的Module下生成类名一样的类，导致编译时出现类重复定义异常），所以&lt;strong&gt;RouteProcessor&lt;/strong&gt;名称为&lt;code&gt;app&lt;/code&gt;的Module下生成的类就是&lt;code&gt;com.github.richardwrq.krouter.KRouter_RouteLoader_app&lt;/code&gt;，在程序运行的时候，我们的SDK只需要获取项目中所有Module的名称，然后依次加载它们并执行&lt;code&gt;loadInto&lt;/code&gt;方法即可。&lt;/p&gt;

&lt;p&gt;基于性能考虑我采取了第二种方案，这就需要解决一个问题，因为&lt;strong&gt;RouteProcessor&lt;/strong&gt;是无法知道当前是处于哪个Module的，所以我们需要在Module的&lt;code&gt;build.gradle&lt;/code&gt;做如下配置：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;kapt {
    arguments {
        arg(&amp;quot;moduleName&amp;quot;, project.getName())
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样我们就配置了一个名为“moduleName”的参数，它的值就是当前Module的名称。这个参数可以在&lt;strong&gt;ProcessingEnvironment&lt;/strong&gt;的&lt;code&gt;getOptions()&lt;/code&gt;方法获取的map中取出，
&lt;strong&gt;Route&lt;/strong&gt;、&lt;strong&gt;Interceptor&lt;/strong&gt;、&lt;strong&gt;Provider&lt;/strong&gt;三者的处理流程大致相同，就不一一赘述了。
在这里提一下关于依赖注入&lt;strong&gt;Inject&lt;/strong&gt;的实现，关于如何对属性进行注入我想了两种解决方案：
1. 第一种就是通过反射，了解反射的同学都知道可以通过反射获取类的运行时注解，并且通过反射API为类的属性进行赋值，但由于时反射，所以性能上有所损耗，但是可以无视属性的访问权限；
2. 第二种是生成需要被注入的类的扩展方法，在扩展方法里面对接收者的属性进行赋值，性能更好，但是缺点是无法对private以及protected成员进行赋值。&lt;/p&gt;

&lt;p&gt;一开始是希望偷懒，就选择了第一种方案，但是问题来了，我知道Java的反射会有一些性能上的问题，但速度还不至于让用户感知明显，但是当我调用kotlin反射相关API时（最主要是获取Properties相关API），发现第一次调用花费的在4~5s 左右，之后调用速度是毫秒级的，我猜测是第一次调用加载了大量数据，然后将这些数据缓存起来了，但这4~5s的调用时间实在是恶心，所以最终还是决定采用方案2，有兴趣的同学可以查看&lt;code&gt;com/github/richardwrq/krouter/compiler/processor/RouteProcessor.kt&lt;/code&gt;，生成的代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class com_github_richardwrq_krouter_activity_Main2Activity_KRouter_Injector : IInjector {
    override fun inject(any: Any, extras: Bundle?) {
        val bundle = getBundle(any, extras)//getBundle为自动生成的顶层方法
        (any as Main2Activity).exInject(bundle)
    }

    private fun Main2Activity.exInject(bundle: Bundle) {
        person = bundle.get(&amp;quot;person&amp;quot;) as? Person ?: KRouter.getProvider&amp;lt;Person&amp;gt;(&amp;quot;person&amp;quot;) ?: parseObject(bundle.getString(&amp;quot;person&amp;quot;), object : TypeToken&amp;lt;Person&amp;gt;() {}.getType()) ?: throw java.lang.NullPointerException(&amp;quot;Field [person] must not be null in [Main2Activity]!&amp;quot;)//parseObject为自动生成的顶层方法
        provider = bundle.get(&amp;quot;NoImplProvider&amp;quot;) as? NoImplProvider ?: KRouter.getProvider&amp;lt;NoImplProvider&amp;gt;(&amp;quot;NoImplProvider&amp;quot;) ?: parseObject(bundle.getString(&amp;quot;NoImplProvider&amp;quot;), object : TypeToken&amp;lt;NoImplProvider&amp;gt;() {}.getType()) ?: throw java.lang.NullPointerException(&amp;quot;Field [provider] must not be null in [Main2Activity]!&amp;quot;)
        myProvider = (KRouter.getProvider&amp;lt;MyProvider&amp;gt;(&amp;quot;provider/myprovider&amp;quot;)) ?: throw java.lang.NullPointerException(&amp;quot;Field [myProvider] must not be null in [Main2Activity]!&amp;quot;)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;生成的类路径与扩展方法接收者的类路径相同（解决Java包内访问权限问题），类名命名规则为扩展方法接收者类路径的“.“替换为”_“作为前缀，后缀为”_KRouter_Injector“，比如被被注入的类是&lt;code&gt;com.github.richardwrq.krouter.activity.Main2Activity&lt;/code&gt;，那么自动生成的类为&lt;code&gt;com.github.richardwrq.krouter.activity.com_github_richardwrq_krouter_activity_Main2Activity_KRouter_Injector&lt;/code&gt;
#####KRouter-api
该模块其实就是提供API给用户调用的SDK
上面提到SDK需要执行&lt;strong&gt;KRouter-compiler&lt;/strong&gt;模块类的代码才能真正完成路由表初始化的工作，由于最终编译器会将所有Module打包成一个apk，所以在APP运行时是不存在Module的概念的，但是按照解决方案2各Module生成的类会以Module名称作为后缀，因此必须想办法让SDK获取到项目中所有Module的名称，考虑再三，我采取的解决方案是从&lt;code&gt;assets&lt;/code&gt;目录入手，在项目构建时期创建一个task，这个task会在Module的&lt;code&gt;src/main/assets&lt;/code&gt;目录下生成一个“KRouter&lt;em&gt;ModuleName”的文件，在SDK初始化的时候只需要列出&lt;code&gt;assets&lt;/code&gt;目录下所有&amp;rdquo;KRouter&lt;/em&gt;&amp;ldquo;开头的文件并截取下划线“_”后的内容，即可得到一个包含所有Module名称的列表。
下面给出SDK的类图，同学们可以对照源码参考
&lt;img src=&#34;https://upload-images.jianshu.io/upload_images/745509-9e7ee15fad22c478.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;KRouter-api类图.png&#34; /&gt;
#####KRouter-gradle-plugin
完成上述两个模块后其实&lt;code&gt;KRouter&lt;/code&gt;框架已经可以正常使用了，引用方式如下：
在各Module的&lt;code&gt;build.gradle&lt;/code&gt;加入下面的代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;kapt {
    arguments {
        arg(&amp;quot;moduleName&amp;quot;, project.getName())
    }
}
dependencies {
    implementation &#39;com.github.richardwrq:krouter-api:x.y.z’
    kapt &#39;com.github.richardwrq:krouter-compiler:x.y.z&#39;
}
afterEvaluate {
    //在assets目录创建文件的task
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当项目中Module较多时，手动在每一个Module加入这些配置未免有些蠢。。所以我写了一个gradle插件用来自动完成这些配置工作，具体实现参考源码，逻辑非常简单，最后使用引用方式变成下面这样：
在项目根目录&lt;code&gt;build.gradle&lt;/code&gt;文件加入如下配置&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;buildscript {

    dependencies {
        classpath &amp;quot;org.jetbrains.kotlin:kotlin-gradle-plugin:x.y.z&amp;quot;
        classpath &amp;quot;com.github.richardwrq:krouter-gradle-plugin:x.y.z&amp;quot;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后在各Module的&lt;code&gt;build.gradle&lt;/code&gt;文件加入如下配置&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;apply plugin: &#39;kotlin-android&#39;
apply plugin: &#39;kotlin-kapt&#39;
apply plugin: &amp;quot;com.github.richardwrq.krouter&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;到这里&lt;code&gt;KRouter&lt;/code&gt;路由框架就粗略的介绍了一遍，由于&lt;code&gt;kapt&lt;/code&gt;仍在不断完善，所以使用过程中难免碰到一些坑或者本身API功能不够完善，下面就列举一些遇到的问题以及解决方法：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.jianshu.com/p/f1ca4314f804&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;注解处理器Annotation Processor中判断Java或kotlin类&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.jianshu.com/p/f41d21850cb4&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;使用kotlinpoet生成kotlin代码数据类型不正确的问题&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;todolist&#34;&gt;ToDoList&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;通过gradle插件修改&lt;code&gt;AndroidManifest.xml&lt;/code&gt;文件，自动注册路由组件（Activity、Service）&lt;/li&gt;
&lt;li&gt;目前尚不支持动态加载的插件的路由注册，但有解决方案，hook classloader装载方法，在加载dex文件时扫描&lt;code&gt;KRouter&lt;/code&gt;的路由组件&lt;/li&gt;
&lt;li&gt;支持多应用多进程环境下的页面路&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>First</title>
      <link>https://richardwrq.github.io/2018/first/</link>
      <pubDate>Fri, 27 Apr 2018 11:12:45 +0800</pubDate>
      
      <guid>https://richardwrq.github.io/2018/first/</guid>
      <description>

&lt;h4 id=&#34;标题&#34;&gt;标题&lt;/h4&gt;

&lt;p&gt;aaa
bbb
&lt;code&gt;ccc&lt;/code&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Second</title>
      <link>https://richardwrq.github.io/2018/second/</link>
      <pubDate>Fri, 27 Apr 2018 10:55:10 +0800</pubDate>
      
      <guid>https://richardwrq.github.io/2018/second/</guid>
      <description></description>
    </item>
    
    <item>
      <title>First</title>
      <link>https://richardwrq.github.io/cards/first/</link>
      <pubDate>Fri, 27 Apr 2018 10:54:59 +0800</pubDate>
      
      <guid>https://richardwrq.github.io/cards/first/</guid>
      <description>

&lt;h4 id=&#34;title&#34;&gt;Title&lt;/h4&gt;

&lt;p&gt;aaaasd
bbb
bcccasd&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title></title>
      <link>https://richardwrq.github.io/404/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://richardwrq.github.io/404/</guid>
      <description>

&lt;h1 id=&#34;error-404-page-not-found&#34;&gt;Error 404: Page Not Found&lt;/h1&gt;

&lt;hr /&gt;

&lt;h4 id=&#34;it-seems-that-the-page-that-you-re-trying-to-access-doesn-t-exist&#34;&gt;It seems that the page that you&amp;rsquo;re trying to access doesn&amp;rsquo;t exist. 😟&lt;/h4&gt;

&lt;h4 id=&#34;if-you-re-sure-that-it-exists-chances-are-it-might-have-been-moved-to-a-new-link-you-may-search-for-it-on-the-home-page&#34;&gt;If you&amp;rsquo;re sure that it exists, chances are it might have been moved to a new link! You may search for it on the home page.&lt;/h4&gt;
</description>
    </item>
    
    <item>
      <title></title>
      <link>https://richardwrq.github.io/about/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://richardwrq.github.io/about/</guid>
      <description>&lt;p&gt;一个程序员&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title></title>
      <link>https://richardwrq.github.io/1/tcpip%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://richardwrq.github.io/1/tcpip%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/</guid>
      <description>

&lt;h2 id=&#34;tcp-ip协议详解&#34;&gt;TCP\IP协议详解&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-本文中用到的图片转自：```&#34;&gt;
#### TCP与UDP协议有什么区别？

**TCP是一个面向连接的、可靠的、基于字节流的传输层协议。**

**UDP是一个面向无连接的传输层协议。**

与UDP相比，TCP有以下特性：

1. **面向连接**。所谓的连接，指的是客户端和服务器的连接，在双方互相通信之前，TCP 需要三次握手建立连接，而 UDP 没有相应建立连接的过程。
2. **可靠性**。TCP 使用了非常多机制的保证连接的可靠，这个可靠性体现在哪些方面呢？一个是有状态，另一个是可控制。
3. **面向字节流**。UDP 的数据传输是基于数据报的，这是因为仅仅只是继承了 IP 层的特性，而 TCP 为了维护状态，将一个个 IP 包变成了字节流。

TCP 会精准记录哪些数据发送了，哪些数据被对方接收了，哪些没有被接收到，而且保证数据包按序到达，不允许半点差错。这是**有状态**。

当意识到丢包了或者网络环境不佳，TCP 会根据具体情况调整自己的行为，控制自己的发送速度或者重发。这是**可控制**。

相应的，UDP 就是无状态, 不可控的。

### 三次握手

在介绍三次握手时我们先来看看TCP的报文头格式：

![img](/Users/wuruiqiang/Documents/Markdown文章/TCP协议详解/823435-20170323092941611-1541980584.png)

- **端口号**：用来标识同一台计算机的不同的应用进程。
- **源端口**：源端口和IP地址的作用是标识报文的返回地址。
- **目的端口**：端口指明接收方计算机上的应用程序接口。（TCP报头中的源端口号和目的端口号同IP数据报中的源IP与目的IP唯一确定一条TCP连接。）
- **序号和确认号**：是TCP可靠传输的关键部分。**序号**是本报文段发送的数据组的第一个字节的序号。在TCP传送的流中，每一个字节一个序号。e.g.一个报文段的序号为300，此报文段数据部分共有100字节，则下一个报文段的序号为400。所以序号确保了TCP传输的有序性。确认号，即ACK，指明下一个期待收到的字节序号，表明该序号之前的所有数据已经正确无误的收到。确认号只有当ACK标志为1时才有效。比如建立连接时，SYN报文的ACK标志位为0。
- **数据偏移／首部长度**：4bits。由于首部可能含有可选项内容，因此TCP报头的长度是不确定的，报头不包含任何可选字段则长度为20字节，4位首部长度字段所能表示的最大值为1111，转化为10进制为15，15*32/8 = 60，故报头最大长度为60字节。首部长度也叫数据偏移，是因为首部长度实际上指示了数据区在报文段中的起始偏移值。
- **保留**：为将来定义新的用途保留，现在一般置0。
- **控制位**：URG  ACK  PSH  RST  SYN  FIN，共6个，每一个标志位表示一个控制功能。
  1. **URG**：紧急指针标志，为1时表示紧急指针有效，为0则忽略紧急指针。
  2. **ACK**：确认序号标志，为1时表示确认号有效，为0表示报文中不含确认信息，忽略确认号字段。
  3. **PSH**：push标志，为1表示是带有push标志的数据，指示接收方在接收到该报文段以后，应尽快将这个报文段交给应用程序，而不是在缓冲区排队。
  4. **RST**：重置连接标志，用于重置由于主机崩溃或其他原因而出现错误的连接。或者用于拒绝非法的报文段和拒绝连接请求。
  5. **SYN**：同步序号，用于建立连接过程，在连接请求中，SYN=1和ACK=0表示该数据段没有使用捎带的确认域，而连接应答捎带一个确认，即SYN=1和ACK=1。
  6. **FIN**：finish标志，用于释放连接，为1时表示发送方已经没有数据发送了，即关闭本方数据流。
- **窗口**：滑动窗口大小，用来告知发送端接受端的缓存大小，以此控制发送端发送数据的速率，从而达到流量控制。窗口大小16bit，因此窗口大小最大为65535。
- **校验和**：奇偶校验，此校验和是对整个的 TCP 报文段，包括 TCP 头部和 TCP 数据，以 16 位字进行计算所得。由发送端计算和存储，并由接收端进行验证。
- **紧急指针**：只有当 URG 标志置 1 时紧急指针才有效。紧急指针是一个正的偏移量，和顺序号字段中的值相加表示紧急数据最后一个字节的序号。 TCP 的紧急方式是发送端向另一端发送紧急数据的一种方式。
- **选项和填充**：最常见的可选字段是最长报文大小，又称为MSS（Maximum Segment  Size），每个连接方通常都在通信的第一个报文段（为建立连接而设置SYN标志为1的那个段）中指明这个选项，它表示本端所能接受的最大报文段的长度。选项长度不一定是32位的整数倍，所以要加填充位，即在这个字段中加入额外的零，以保证TCP头是32的整数倍。
- **数据部分**： TCP 报文段中的数据部分是可选的。在一个连接建立和一个连接终止时，双方交换的报文段仅有 TCP 首部。如果一方没有数据要发送，也使用没有任何数据的首部来确认收到的数据。在处理超时的许多情况中，也会发送不带任何数据的报文段。

报头格式介绍完了，接下来我们看看TCP的三次握手过程：

![img](/Users/wuruiqiang/Documents/Markdown文章/TCP协议详解/823435-20170323092953893-1865298744.png)

**过程描述：**

- 客户端发起连接请求，报头中的SYN=1，ACK=0，TCP规定SYN=1时不能携带数据，但要消耗一个序号,因此声明自己的序号是 seq=x。此时客户端状态**CLOSED**-&amp;gt;**SYN-SENT**；
- 服务器接收到连接请求，然后进行回复确认，发送SYN=1 ACK=1 seq=y ack=x+1。此时服务端状态**LISTEN**-&amp;gt;**SYN-RCVD**
- 客户端收到对SYN的确认包之后再次确认，SYN=0 ACK=1 seq=x+1 ack=y+1，此时客户端状态**SYN-SENT**-&amp;gt;**ESTABLISHED**
- 服务端接收到客户端的确认包后状态变为**ESTABLISHED**

**为什么要进行三次握手？**

保证通信是“全双工”的，即客户端和服务器都具备发送和接收能力，假如没有客户端的第二次确认，那么服务端无法确保客户端已经接收到自己发出去的SYN确认包。而且假如只有两次握手，那么会存在资源浪费的情况：

客户端发出SYN请求后，由于网络复杂情况，这个请求一直没有发送到服务器端，这时候客户端超时重发第二个请求，然后第二个请求服务端正常接收并建立连接，数据传输完毕后双方断开了连接，但这时候第一次发送的那个SYN包终于到达服务端了，由于是二次握手，所以服务端发送确认包，并建立连接，但是客户端实际上已经断开连接了，而服务端建立了一条“没有”客户端的连接，造成了资源浪费。

#### 重传机制

三次握手结束之后就可以开始收发数据了，那要怎么保证我们发送出去的消息确实被接收到了呢？以寄快递为例，虽然我们寄快递前确认收件人信息无误，但是快递寄出去的时候，如果我们没有收到反馈（比如收件人告知你快递我已经收到了或者是快递公司的收件通知）。那么我们是无法知道快递是否准确送达的。

在TCP中，是通过序列号与确认应答来保证的（回想下上面的报头格式）。正常的传输过程如下：

![img](/Users/wuruiqiang/Documents/Markdown文章/TCP协议详解/6f12b7827bba411b8d20d8a8b5b50bba.png)

但是实际情况是非常复杂的，假如网络出现丢包的情况要怎么办呢？这就涉及到TCP的**重传机制**：

- 超时重传
- 快速重传
- SACK
- D-SACK

#### 超时重传

在发送数据时，设定一个定时器，当超过指定的时间后，没有收到对方的 ACK 确认应答报文，就会重发该数据。

在**数据包丢失**或者**确认应答丢失**时会发生超时重传：

![img](/Users/wuruiqiang/Documents/Markdown文章/TCP协议详解/1189ad86c82847d5a4d2a325312bfab4.png)

问题来了，这个“特定的时间间隔”应该设置成多少合适呢？这就引入了RTT（Round-Trip Time 往返时延）的概念：

![img](/Users/wuruiqiang/Documents/Markdown文章/TCP协议详解/cf10b4cef2284178942306dcd5ac17a8.png)

RTT简单来说就是**数据一次往返的时间**，超时重传时间是以 RTO （Retransmission Timeout 超时重传时间）表示。这个重传时间的设置比较玄学，设置高了或者低了都会有问题：

![img](/Users/wuruiqiang/Documents/Markdown文章/TCP协议详解/9a0a2e09eee245b8a2fdac908530fb96.png)

其实不用看图片大家应该也能猜到，超时时间过大，那么就会导致效率的降低（大部分时间都用来等待）。超时时间过低的话那就有可能造成不必要的重传（重传刚发出去结果就收到了应答）。

所以RTO的计算方法比较复杂，因为网络状态是时时刻刻变化的，而且也会存在波动较大的情况，所以RTO的值也是动态变化的，这里面的算法就不赘述了~~~有兴趣的小伙伴可以网上查找相关资料。

##### 快速重传

我们一直强调网络情况是非常复杂的，所以上面提到的超时重传无法解决所有问题，设想这么一种场景：数据包只是因为某一个网络节点的异常而丢失了，实际上网路是“畅通”的，假如还是使用超时重传那么效率显然太低了，因此，快速重传机制诞生了。

![img](/Users/wuruiqiang/Documents/Markdown文章/TCP协议详解/fd8888b8b0b440788f3c875d1ba4436c.png)

- 发送端发送了5份数据；
- 接收方接收到seq1时返回ACK2，但是seq2由于网络异常丢包没有收到；
- 这时候接收端又接收到seq3，在应答的时候依然返回ACK2；
- 后续seq4和seq5也收到了，但是seq2还没有收到，依然返回ACK2。
- 发送端连续收到三次同样的ACK2，知道seq2没有被接收到，就会在定时器任务触发之前重传seq2。
- 接收端接收到seq2，而且检测到seq3、4、5都已经收到。所以返回ACK6

所以，快速重传的工作方式是当收到三个相同的 ACK 报文时，会在定时器过期之前，重传丢失的报文段。

但是快速重传也有问题，发送端只知道seq2丢失了，但是不知道seq3、4、5有没有被接收到。所以发送端并不清楚要不要把后续的seq3、4、5一并重传。于是便引入了SACK

##### SACK（ Selective Acknowledgment 选择性确认）

这种方式需要在 TCP 头部「选项」字段里加一个 SACK，他可以记录已接收的数据，随着报头一起发送给发送方，这样发送方就清楚什么数据被接收了，什么数据没有接收，这样就可以只重传丢失的数据。

![img](/Users/wuruiqiang/Documents/Markdown文章/TCP协议详解/7135037248b348c2bf2d37e46750ff9d.png)

发送方收到了三次同样的 ACK 确认报文，于是就会触发快速重发机制，通过SACK 信息发现只有 200~299 这段数据丢失，重发时只需要重传这段数据即可。

```如果要支持 SACK，必须双方都要支持。在 Linux 下，可以通过 net.ipv4.tcp_sack参数打开这个功能（Linux 2.4 后默认打开）。```

##### Duplicate SACK

Duplicate SACK 又称 D-SACK，其主要**使用了 SACK 来告诉「发送方」有哪些数据被重复接收了。** 主要解决下面两种情况：

![img](/Users/wuruiqiang/Documents/Markdown文章/TCP协议详解/732bc94fd4714c95ae94262f15224d3e.png)

ACK丢包。

![img](/Users/wuruiqiang/Documents/Markdown文章/TCP协议详解/ab58dca206e14b35a0fbed4d6799113e.png)

网络延时。

在 Linux 下可以通过 net.ipv4.tcp_dsack 参数开启/关闭这个功能（Linux 2.4 后默认打开）。

#### 滑动窗口

细心的小伙伴可能发现了，上面的图片里面并不是等到上一次数据的确认收到之后才发送下一批数据，因为串行发送数据效率太低，所以TCP引入了**滑动窗口**的概念。

有了窗口，就可以指定窗口大小，窗口大小就是指**无需等待确认应答，而可以继续发送数据的最大值**。

窗口的实现实际上是操作系统开辟的一个缓存空间，发送方主机在等到确认应答返回之前，必须在缓冲区中保留已发送的数据。如果按期收到确认应答，此时数据就可以从缓存区清除。

假设窗口大小为 3 个 TCP 段，那么发送方就可以「连续发送」 3 个 TCP 段，并且中途若有 ACK 丢失，可以通过「下一个确认应答进行确认」。如下图：

![img](/Users/wuruiqiang/Documents/Markdown文章/TCP协议详解/04973b1e0f99426cad89c0e8a826c6ac.png)

图中的 ACK 600 确认应答报文丢失，也没关系，因为可以通过下一个确认应答进行确认，只要发送方收到了 ACK 700 确认应答，就意味着 700 之前的所有数据「接收方」都收到了。这个模式就叫**累计确认**或者**累计应答**。

&amp;gt; 那么窗口大小应该怎么设置呢？

回想一下TCP报头格式，是不是有一个“窗口”字段？这个“窗口”字段就是用来表示窗口大小的。**这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据接收端的处理能力来发送数据，而不会导致接收端处理不过来。**

所以，通常窗口的大小是由接收方的决定的。

发送方发送的数据大小不能超过接收方的窗口大小，否则接收方就无法正常接收到数据。

下图就是发送方缓存的数据，根据处理的情况分成四个部分，其中深蓝色方框是发送窗口，紫色方框是可用窗口：

![img](/Users/wuruiqiang/Documents/Markdown文章/TCP协议详解/b441c3f5328a42c6b00ff34b02391aa4.png)

在下图，当发送方把数据「全部」都一下发送出去后，可用窗口的大小就为 0 了，表明可用窗口耗尽，在没收到 ACK 确认之前是无法继续发送数据了。

![img](/Users/wuruiqiang/Documents/Markdown文章/TCP协议详解/fbec4c0bf70e4f6991cac1f3464b06f2.png)

在下图，当收到之前发送的数据 32~36 字节的 ACK 确认应答后，如果发送窗口的大小没有变化，则**滑动窗口往右边移动 5 个字节，因为有 5 个字节的数据被应答确认**，接下来 52~56 字节又变成了可用窗口，那么后续也就可以发送 52~56 这 5 个字节的数据了。

![img](/Users/wuruiqiang/Documents/Markdown文章/TCP协议详解/991afb2eae7e4a4794b85b5b3ac3a7c6.png)

TCP 滑动窗口方案使用三个指针来跟踪在四个传输类别中的每一个类别中的字节。其中两个指针是绝对指针（指特定的序列号），一个是相对指针（需要做偏移）。

![img](/Users/wuruiqiang/Documents/Markdown文章/TCP协议详解/ce6a66c5f9254eca8324cf4b57772fc0.png)

- SND.WND：表示发送窗口的大小（大小是由接收方指定的）；
- SND.UNA：是一个绝对指针，它指向的是已发送但未收到确认的第一个字节的序列号，也就是 #2 的第一个字节。
- SND.NXT：也是一个绝对指针，它指向未发送但可发送范围的第一个字节的序列号，也就是 #3 的第一个字节。
- 指向 #4 的第一个字节是个相对指针，它需要 SND.NXT 指针加上 SND.WND大小的偏移量，就可以指向 #4 的第一个字节了。

**可用窗口大小 = SND.WND -（SND.NXT - SND.UNA）**

接下来是接收端的窗口

![img](/Users/wuruiqiang/Documents/Markdown文章/TCP协议详解/1e87fab0380f4dc5b1dbb102ebee3cf0.png)

- RCV.WND：表示接收窗口的大小，它会通告给发送方。
- RCV.NXT：是一个指针，它指向期望从发送方发送来的下一个数据字节的序列号，也就是 #3 的第一个字节。
- 指向 #4 的第一个字节是个相对指针，它需要 RCV.NXT 指针加上 RCV.WND大小的偏移量，就可以指向 #4 的第一个字节了。

&amp;gt; 接收窗口≈发送窗口

因为滑动窗口是一直在变化的，假如接收方的应用读取数据的速度很快，那么接收窗口就很快就可以腾出空间，但是在把新的接收窗口大小发给发送端的时候是存在时延的，所以发送窗口约等于接收窗口。

#### 流量控制

从上面我们可以知道接收端是有接收窗口的，接收方的应用在处理数据时也需要一定的时间，假如发送方不加以控制，那么接收方将无法处理过多的数据，导致出发重传机制，从而浪费网络流量。

为了解决这种现象发生，**TCP 提供一种机制可以让「发送方」根据「接收方」的实际接收能力控制发送的数据量，这就是所谓的流量控制。**

我们先看看假设接收窗口和发送窗口保持200不变的发送过程：

![img](/Users/wuruiqiang/Documents/Markdown文章/TCP协议详解/12b6a363c7a34ce7934bfe3f378e32e5.png)

1. 客户端发送请求数据报文。
2. 服务端接收到请求，发送确认以及80字节数据，这时发送窗口的SND.UNA = 241, SND.NXT = SND.WND + 80 = 321。可用发送窗口大小 = 200 - ( 321 - 241) = 120。
3. 客户端接收到数据，这时接收窗口RCV.NXT = RCV.NXT + 80 = 321，发送确认报文。
4. 发送端继续发送120个字节，由于这时还没收到客户端的确认数据包，发送窗口SND.UNA = 241, SND.NXT = 321 + 120 = 441，可用发送窗口大小 = 200 - (441 - 241) = 0，可用窗口大小为0，这时无法再发送数据。
5. 客户端接收到120字节数据，RCV.NXT = 321 + 120 = 441，发送确认报文。
6. 服务端收到客户端的第一个确认报文，窗口往右”滑动“80字节，SND.UNA = 241 + 80 = 321, 可用发送窗口大小 = 200 - (441 - 321) = 80。
7. 服务端收到客户端的第二个确认报文，窗口往右”滑动“120字节，SND.UNA = 321 + 120 = 441, 可用发送窗口大小 = 200 - (441 - 441) = 200。
8. 服务端继续发送160个字节数据，SND.NXT = 441 + 160 = 601，可用发送窗口大小 = 200 - (601 - 441) = 40。
9. 客户端接收到数据，RCV.NXT = 441 + 160 = 601，发送确认报文。
10. 服务端收到确认报文，窗口右移160个字节，SND.UNA = 441 + 160 = 601，可用发送窗口大小 = 200 - (601 - 601) = 200。

上面的例子我们假定了发送窗口和接收窗口是不变的，但是实际上，发送窗口和接收窗口中所存放的字节数，都是放在操作系统内存缓冲区中的，而操作系统的缓冲区，会**被操作系统调整**。当应用进程没办法及时读取缓冲区的内容时，也会对我们的缓冲区造成影响。

我们来看下面这个例子：

![img](/Users/wuruiqiang/Documents/Markdown文章/TCP协议详解/dd15c2eaed554c5e8d1a6074f9287f9a.png)

1. 客户端发送 140 字节数据后，可用窗口变为 220 （360 - 140）。
2. 服务端收到 140 字节数据，**但是服务端非常繁忙，应用进程只读取了 40 个字节，还有 100 字节占用着缓冲区，于是接收窗口收缩到了 260 （360 - 100）**，最后发送确认信息时，将窗口大小通过给客户端。
3. 客户端收到确认和窗口通告报文后，发送窗口减少为 260。
4. 客户端发送 180 字节数据，此时可用窗口减少到 80。
5. 服务端收到 180 字节数据，**但是应用程序没有读取任何数据，这 180 字节直接就留在了缓冲区，于是接收窗口收缩到了 80 （260 - 180）**，并在发送确认信息时，通过窗口大小给客户端。
6. 客户端收到确认和窗口通告报文后，发送窗口减少为 80。
7. 客户端发送 80 字节数据后，可用窗口耗尽。
8. 服务端收到 80 字节数据，**但是应用程序依然没有读取任何数据，这 80 字节留在了缓冲区，于是接收窗口收缩到了 0**，并在发送确认信息时，通过窗口大小给客户端。
9. 客户端收到确认和窗口通告报文后，发送窗口减少为 0。

可见最后窗口都收缩为 0 了，也就是发生了窗口关闭。我们再来看下面的例子：

当服务端系统资源非常紧张的时候，操心系统可能会直接减少了接收缓冲区大小，这时应用程序又无法及时读取缓存数据，会出现数据包丢失的现象。

![img](/Users/wuruiqiang/Documents/Markdown文章/TCP协议详解/f1d7e77abbda46469059356ab5bef342.png)

1. 客户端发送 140 字节的数据，于是可用窗口减少到了 220。
2. **服务端因为现在非常的繁忙，操作系统于是就把接收缓存减少了 100 字节，当收到 对 140 数据确认报文后，又因为应用程序没有读取任何数据，所以 140 字节留在了缓冲区中，于是接收窗口大小从 360 收缩成了 100**，最后发送确认信息时，通告窗口大小给对方。
3. 此时客户端因为还没有收到服务端的通告窗口报文，所以不知道此时接收窗口收缩成了 100，客户端只会看自己的可用窗口还有 220，所以客户端就发送了 180 字节数据，于是可用窗口减少到 40。
4. 服务端收到了 180 字节数据时，**发现数据大小超过了接收窗口的大小，于是就把数据包丢弃了。**
5. 客户端收到服务端发送的确认报文和通告窗口报文，尝试减少发送窗口到 100，把窗口的右端向左收缩了 80，此时可用窗口的大小就会出现诡异的负值。

所以，如果发生了先减少缓存，再收缩窗口，就会出现丢包的现象。

**为了防止这种情况发生，TCP 规定是不允许同时减少缓存又收缩窗口的，而是采用先收缩窗口，过段时间再减少缓存，这样就可以避免了丢包情况。**

#### 窗口关闭

**如果窗口大小为 0 时，就会阻止发送方给接收方传递数据，直到窗口变为非 0 为止，这就是窗口关闭。**

窗口大小是通过ACK报文发送的，当发生窗口关闭时，接收方处理完数据后，会向发送方通告一个窗口非 0 的 ACK 报文，如果这个通告窗口的 ACK 报文在网络中丢失了，那么就会产生“死锁”：

![img](/Users/wuruiqiang/Documents/Markdown文章/TCP协议详解/43313a8faf394caa91e79f5b98a588ff.png)

发送方一直等待接收方的非 0 窗口通知，接收方也一直等待发送方的数据，如不不采取措施，这种相互等待的过程，会造成了死锁的现象。

为了解决这个问题，TCP 为每个连接设有一个持续定时器，**只要 TCP 连接一方收到对方的零窗口通知，就启动持续计时器。**

如果持续计时器超时，就会发送**窗口探测 ( Window probe ) 报文**，而对方在确认这个探测报文时，给出自己现在的接收窗口大小。窗口探测的次数一般为 3 次，每次大约 30-60 秒（不同的系统版本实现可能会不一样）。如果探测 3 次过后接收窗口还是 0 的话，有的 TCP 实现就会发 RST 报文来中断连接。

![img](/Users/wuruiqiang/Documents/Markdown文章/TCP协议详解/aaf3fcf91251423bac05cc99d7488f7a.png)

#### 糊涂窗口综合征

如果接收方太忙了，来不及取走接收窗口里的数据，那么就会导致发送方的发送窗口越来越小。

到最后，**如果接收方腾出几个字节并告诉发送方现在有几个字节的窗口，而发送方会义无反顾地发送这几个字节，这就是糊涂窗口综合症**。

我们的 TCP + IP 头至少有 40 个字节，假如接收窗口只有几字节，那么就会出现大马拉小车的情况，造成资源浪费。

![img](/Users/wuruiqiang/Documents/Markdown文章/TCP协议详解/5acc0648ee364bbba1917ea0a662d729.png)

参考上图我们不难想象会有两种场景导致“大马拉小车”：

- 接收端发送了一个接收窗口很小的ACK包；
- 发送端任性的发送小数据包。

&amp;gt; 如何避免发送小窗口ACK包

当「窗口大小」小于 min( MSS，缓存空间/2 ) ，也就是小于 MSS 与 1/2 缓存大小中的最小值时，就会向发送方通告窗口为 0，也就阻止了发送方再发数据过来。

等到接收方处理了一些数据后，窗口大小 &amp;gt;= MSS，或者接收方缓存空间有一半可以使用，就可以把窗口打开让发送方发送数据过来。

&amp;gt; 如何防止发送端发送小数据包

使用 Nagle 算法，该算法的思路是延时处理，它满足以下两个条件中的一条才可以发送数据

- 要等到窗口大小 &amp;gt;= MSS 或是 数据大小 &amp;gt;= MSS
- 收到之前发送数据的 ack 回包

只要没满足上面条件中的一条，发送方就一直囤积数据，直到满足上面的发送条件。

另外，Nagle 算法默认是打开的，如果对于一些需要小数据包交互的场景的程序，比如，telnet 或 ssh 这样的交互性比较强的程序，则需要关闭 Nagle 算法。

可以在 Socket 设置 TCP_NODELAY 选项来关闭这个算法（关闭 Nagle 算法没有全局参数，需要根据每个应用自己的特点来关闭）

```c++
setsockopt(sock_fd, IPPROTO_TCP, TCP_NODELAY, (char *)&amp;amp;value, sizeof(int));
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;拥塞控制&#34;&gt;拥塞控制&lt;/h4&gt;

&lt;p&gt;可能有的小伙伴会有疑问，前面既然有了流量控制，为什么还需要一个拥塞控制呢？其实细想我们不难发现，流量控制只是避免了发送方向接收方发送过多的数据，防止接收方无法及时响应。他们并不能感知到当前的网络状态是否拥堵。这就好比平时节假日出游时，我们总能遇到堵车的情况一样，因为在出门的时候我们没有查询当前的交通情况，刚好大部分人都选择在同一天出行，那显然就容易出现交通拥堵的情况了。&lt;/p&gt;

&lt;p&gt;要解决这个问题也不难，只要大家在出门前先通过APP查询当前交通状况，如果发现交通已经比较拥挤了，那就选择改天再出门，选择错峰出行，那交通出现拥堵的概率就会降低。&lt;/p&gt;

&lt;p&gt;TCP其实也是通过类似的方式去解决网络拥塞的，当网络发送拥塞时，TCP 会选择降低发送的数据量。&lt;/p&gt;

&lt;h5 id=&#34;拥塞窗口&#34;&gt;拥塞窗口&lt;/h5&gt;

&lt;p&gt;在介绍拥塞控制算法前先介绍一个概念，&lt;strong&gt;拥塞窗口（CWND）&lt;/strong&gt;。它是发送方维护的一个 的状态变量，它会根据&lt;strong&gt;网络的拥塞程度动态变化&lt;/strong&gt;，前面提到过发送窗口 swnd 和接收窗口 rwnd 是约等于的关系，那么由于入了拥塞窗口的概念后，此时发送窗口的值是swnd = min(cwnd, rwnd)，也就是拥塞窗口和接收窗口中的最小值。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;只要网络中没有出现拥塞，cwnd 就会增大&lt;/li&gt;
&lt;li&gt;网络中出现了拥塞，cwnd 就减小&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;接下来我们先解决第一个问题，TCP怎么知道当前的网络是否拥塞呢？&lt;/p&gt;

&lt;p&gt;很简单，只要发送端没有在规定的时间内收到ACK应答报文（触发了超时重传），那么就认为网络出现了拥塞。&lt;/p&gt;

&lt;p&gt;判断网络出现拥塞后，TCP就会执行下面四个算法：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;慢启动&lt;/li&gt;
&lt;li&gt;拥塞避免&lt;/li&gt;
&lt;li&gt;拥塞发生&lt;/li&gt;
&lt;li&gt;快速恢复&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;慢启动&#34;&gt;慢启动&lt;/h5&gt;

&lt;p&gt;TCP在连接建立之时，会通过&lt;strong&gt;慢启动&lt;/strong&gt;的方式逐渐增加发送数据量。&lt;strong&gt;慢启动&lt;/strong&gt;算法核心是：&lt;strong&gt;当发送方每收到一个 ACK，就拥塞窗口 cwnd 的大小就会加 1&lt;/strong&gt;。假定拥塞窗口 cwnd 和发送窗口 swnd 相等。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;连接建立完成后，一开始初始化 cwnd = 1，表示可以传一个 MSS（MSS就是连接请求时在报头设置的字段）大小的数据。&lt;/li&gt;
&lt;li&gt;当收到一个 ACK 确认应答后，cwnd 增加 1，于是一次能够发送 2 个&lt;/li&gt;
&lt;li&gt;当收到 2 个的 ACK 确认应答后， cwnd 增加 2，于是就可以比之前多发2 个，所以这一次能够发送 4 个&lt;/li&gt;
&lt;li&gt;当这 4 个的 ACK 确认到来的时候，每个确认 cwnd 增加 1， 4 个确认 cwnd 增加 4，于是就可以比之前多发 4 个，所以这一次能够发送 8 个。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://richardwrq.github.io/Users/wuruiqiang/Documents/Markdown文章/TCP协议详解/64e25531483f45609e8afab1cbf13659.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;慢启动窗口是呈指数增长的，如果任由它一直增长下去毫无疑问网络会出现拥堵，所以TCP设置了一个阈值，它就是慢启动门限 ssthresh （slow start threshold）状态变量。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;当 cwnd &amp;lt; ssthresh 时，使用慢启动算法。&lt;/li&gt;
&lt;li&gt;当 cwnd &amp;gt;= ssthresh 时，就会使用「拥塞避免算法」。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;拥塞避免算法&#34;&gt;拥塞避免算法&lt;/h5&gt;

&lt;p&gt;当拥塞窗口 cwnd 「超过」慢启动门限 ssthresh 就会进入拥塞避免算法。一般来说 ssthresh 的大小是 65535 字节。进入拥塞避免算法后，它的规则是：&lt;strong&gt;每当收到一个 ACK 时，cwnd 增加 1/cwnd。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;接上前面的慢启动的例子，假定 ssthresh 为 8：&lt;/p&gt;

&lt;p&gt;当 8 个 ACK 应答确认到来时，每个确认增加 1/8，8 个 ACK 确认 cwnd 一共增加 1，于是这一次能够发送 9 个 MSS 大小的数据，变成了&lt;strong&gt;线性增长&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://richardwrq.github.io/Users/wuruiqiang/Documents/Markdown文章/TCP协议详解/7755f60e427b4ed2bdd1aa769b8512cd.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;拥塞避免算法就是将原本慢启动算法的指数增长变成了线性增长。&lt;/p&gt;

&lt;p&gt;随着发送量增大，网络慢慢就会出现拥塞，这时候就会出现丢包，进而触发重传。当触发重传机制，那么就会启动&lt;strong&gt;拥塞发生算法&lt;/strong&gt;。&lt;/p&gt;

&lt;h5 id=&#34;拥塞发生&#34;&gt;拥塞发生&lt;/h5&gt;

&lt;p&gt;需要注意的是，上面我们介绍过两种重传机制：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;超时重传&lt;/li&gt;
&lt;li&gt;快速重传&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这两种重传机制对应两种不同的异常：超时重传是网络出现拥堵，无法快速处理所有数据包，所以导致数据包“堵”在网络当中；而快速重传是由于网络异常从而导致某一个数据包“失踪”了，而网络实际是畅通的。&lt;/p&gt;

&lt;p&gt;因此针对这两种异常，TCP同样选择两种算法处理：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;拥塞发生&amp;lt;=&amp;gt;超时重传&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;ssthresh 设为 cwnd/2，&lt;/li&gt;
&lt;li&gt;cwnd 重置为 1&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://richardwrq.github.io/Users/wuruiqiang/Documents/Markdown文章/TCP协议详解/6310fe3872a04422bd251960507a06d1.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;从图中不难看出，这种算法呈现的是“断崖式下跌”（还好不是股市）。如果只采用这种拥塞发生算法的话，那么网络的波动就会非常大，体现在打游戏时突然延迟很高~~&lt;/p&gt;

&lt;p&gt;接下来就介绍针对&lt;strong&gt;快速重传&lt;/strong&gt;的拥塞发生算法——&lt;strong&gt;快速恢复&lt;/strong&gt;，因为发送方还能连续收到3个ACK，说明网络情况还比较乐观。ssthresh 和cwnd 变化如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;cwnd = cwnd/2 ，也就是设置为原来的一半;&lt;/li&gt;
&lt;li&gt;ssthresh = cwnd;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;快速恢复&#34;&gt;快速恢复&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;拥塞窗口 cwnd = ssthresh + 3 （ 3 的意思是确认有 3 个数据包被收到了）&lt;/li&gt;
&lt;li&gt;重传丢失的数据包&lt;/li&gt;
&lt;li&gt;如果再收到重复的 ACK，那么 cwnd 增加 1&lt;/li&gt;
&lt;li&gt;如果收到新数据的 ACK 后，设置 cwnd 为 ssthresh，接着就进入了拥塞避免算法&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://richardwrq.github.io/Users/wuruiqiang/Documents/Markdown文章/TCP协议详解/25061b045a9c4883a879a48d57635f6f.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;四次挥手说再见&#34;&gt;四次挥手说再见&lt;/h4&gt;

&lt;p&gt;&lt;img src=&#34;https://richardwrq.github.io/Users/wuruiqiang/Documents/Markdown文章/TCP协议详解/823435-20170323093037486-665986934.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;MSL是Maximum Segment Lifetime的英文缩写，可译为“最长报文段寿命”，它是任何报文在网络上存在的最长的时间，超过这个时间报文将被丢弃。我们都知道IP头部中有个TTL字段，TTL是time to live的缩写，可译为“生存时间”，这个生存时间是由源主机设置初始值但不是存在的具体时间，而是一个IP数据报可以经过的最大路由数，每经过一个路由器，它的值就减1，当此值为0则数据报被丢弃，同时发送ICMP报文通知源主机。RFC793中规定MSL为2分钟，但这完全是从工程上来考虑，对于现在的网络，MSL=2分钟可能太长了一些。因此TCP允许不同的实现可根据具体情况使用更小的MSL值。TTL与MSL是有关系的但不是简单的相等关系，MSL要大于TTL。&lt;/p&gt;

&lt;p&gt;在TIME_WAIT状态时两端的端口不能使用，要等到2MSL时间结束才可继续使用。当连接处于2MSL等待阶段时任何迟到的报文段都将被丢弃。不过在实际应用中可以通过设置SO_REUSEADDR选项达到不必等待2MSL时间结束再使用此端口。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;当客户端没有东西要发送时就要释放连接，客户端会发送一个报文（没有数据），其中 FIN 设置为1,  服务端收到后会恢复确认，这时客户端的连接已经关闭，即客户端不再发送信息（但仍可接收信息）。  客户端收到确认后进入等待状态，等待服务端请求释放连接， 服务端数据发送完毕后就向客户端请求连接释放，同样是用FIN=1 表示， 并且用 ack =  u+1(如图）， 客户端收到后同样回复一个确认，并进入 TIME_WAIT 状态， 等待 2MSL 时间。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;为什么需要等待？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;因为服务端接收到释放连接的请求后会发送确认信息，这个确认信息是有可能丢失的，所以客户端就需要等待，如果超时还没收到确认，那么就会再次发送释放连接的请求。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;为什么客户端在FIN-WAIT-2阶段发送ACK后还需要等待2MSL&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;1.为了保证客户端（我们记为A端）发送的最后一个ACK报文段能够到达服务器端。这个ACK报文段有可能丢失，因而使处在LASK—ACK端的服务器端（我们记为B端）收不到对已发送的FIN+ACK报文段。B会超时重传这个FIN+ACK报文段，而A就能在2MSL时间内收到这个重传的FIN+ACK报文段。接着A重传一次确认，重新启动2MSL计时器。最后，A和B都正常进入到CLOSED状态。如果A在TIME_WAIT状态不等待一段时间，而是在发送完ACK确认后立即释放连接，那么就无法收到B重传的FIN+ACK报文段，因而也不会再发送一次确认报文段，这样，B就无法正常进入CLOSED状态。&lt;/p&gt;

&lt;p&gt;2.我们都知道，假如A发送的第一个请求连接报文段丢失而未收到确认，A就会重传一次连接请求，后来B收到了确认，建立了连接。数据传输完毕后，就释放了连接。A共发送了两个连接请求报文段，其中第一个丢失，第二个到达了B。假如现在A发送的第一个连接请求报文段没有丢失，而是在某些网络节点长时间都留了，以至于延误到连接释放后的某个时间才到达B，这本来是已失效的报文段，但B并不知道，就会又建立一次连接。而等待的这2MSL就是为了解决这个问题的，A在发送完最后一个确认报后，在经过时间2MSL，就可以使本链接持续时间内所产生的所有报文段都从网络中消失，这样就可以使下一个新的连接中不会出现这种旧的连接请求报文段。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>