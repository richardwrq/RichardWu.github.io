<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>RichardWu&#39;s Blog on RichardWu&#39;s Blog</title>
    <link>https://richardwrq.github.io/</link>
    <description>Recent content in RichardWu&#39;s Blog on RichardWu&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <lastBuildDate>Fri, 21 Dec 2018 14:20:24 +0800</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Android组件化之路</title>
      <link>https://richardwrq.github.io/2018/android%E7%BB%84%E4%BB%B6%E5%8C%96%E4%B9%8B%E8%B7%AF/</link>
      <pubDate>Fri, 21 Dec 2018 14:20:24 +0800</pubDate>
      
      <guid>https://richardwrq.github.io/2018/android%E7%BB%84%E4%BB%B6%E5%8C%96%E4%B9%8B%E8%B7%AF/</guid>
      <description>

&lt;h2 id=&#34;android组件化之路&#34;&gt;Android组件化之路&lt;/h2&gt;

&lt;p&gt;首先先分清楚两个概念：&lt;/p&gt;

&lt;h3 id=&#34;模块化&#34;&gt;模块化&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Modular_programming&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;模块化编程&lt;/a&gt;是将一个程序按照功能拆分成相互独立的若干模块，它强调将程序的&lt;strong&gt;功能&lt;/strong&gt;分离成独立的、可替换的模块。每个模块内只有与其相关功能的内容。&lt;/p&gt;

&lt;p&gt;模块化编程和结构化编程与面向对象编程是密切相关的，它们的目的都是将大型软件程序划分成一个个更小的部分。模块化编程的粒度会更“粗”一些。在Java9中也在编译器层面提供了模块化的支持：&lt;a href=&#34;https://en.wikipedia.org/wiki/Java_Platform_Module_System&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;Java Platform Module System&lt;/a&gt; 。&lt;/p&gt;

&lt;p&gt;组件是一个类似的概念，但通常指更高的级别；组件是整个系统的一部分，而模块是单个程序的一部分。“模块”一词因语言而有很大差异；在Python中，它非常小，每个文件都是一个模块，而在Java 9中，它是非常大的，其中模块是包的集合，包又是文件的集合。&lt;/p&gt;

&lt;p&gt;在面向对象编程中，通常使用接口作为模块间通信的桥梁，也就是基于接口的编程。&lt;/p&gt;

&lt;h3 id=&#34;组件化&#34;&gt;组件化&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Component-based_software_engineering&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;组件化开发&lt;/a&gt;是软件工程的一个分支，它强调对给定软件系统中广泛可用的功能进行分割。基于可重用的目的将一个大的软件系统拆分成多个独立的组件，减少系统耦合度。&lt;/p&gt;

&lt;p&gt;组件化开发中认为组件作为系统的一部分，是可独立运行的服务，维基百科中举了一个例子：在web服务中，有一种面向服务的架构设计&amp;ndash;&lt;a href=&#34;https://en.wikipedia.org/wiki/Service-oriented_architecture&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;service-oriented architectures&lt;/a&gt; (SOA)，这种架构设计从业务角度出发，利用企业现有的各种软件体系，重新整合并构建起一套新的软件架构。这套软件架构可以随着业务的变化，随时灵活地结合现有服务，组成一个新的软件。增加应用系统的灵活性。&lt;/p&gt;

&lt;p&gt;组件可以产生或者消费事件，也可以应用于事件驱动架构。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;组件之间通过接口进行通信&lt;/li&gt;
&lt;li&gt;组件是可替换的，如果后续组件满足初始组件的需求（通过接口表示），则组件可以替换另一个组件（在设计时或运行时），因此可以用更新的版本或替代的版本替换组件，而不会破坏系统的运行。&lt;/li&gt;
&lt;li&gt;一个判断可替换组件的经验法则是：如果组件B至少提供了A提供的组件，并且使用的组件不超过A使用的组件，那么组件B可以立即替换组件A&lt;/li&gt;
&lt;li&gt;当组件直接与用户交互时，应该考虑基于组件的可用性测试。&lt;/li&gt;
&lt;li&gt;组件需要是完全文档化、全面测试、具有全面的输入效度检查的。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;模块化-or-组件化&#34;&gt;模块化 or 组件化&lt;/h3&gt;

&lt;p&gt;不管是模块化还是组件化，都不是一个新的设计思想，它们最早都是在20世纪60年代就已经被提出了，但是早期的移动应用由于相对简单，本身逻辑功能也不多，所以在移动端的应用反而没那么广泛。（虽然Java最开始的模块化是针对在移动和嵌入式设备上的应用设计的）。&lt;/p&gt;

&lt;p&gt;从上面的概述来看其实组件化跟模块化没有明显的区别；一个登录功能可以是一个模块也可以是一个组件，一个日期选择控件可以是一个模块，也可以是一个组件，因为不管是模块化还是组件化，它们都有一个共同的目标：将一个大的软件系统细化成一个个模块或者组件，都是为了重用和解耦。因此没有一个明确的界线去区分它们。&lt;/p&gt;

&lt;p&gt;网上很多文章对于&lt;strong&gt;组件&lt;/strong&gt;和&lt;strong&gt;模块&lt;/strong&gt;的定义也是不尽相同的，一些人认为组件的粒度更细，它只是具备单一功能与业务无关的组件，比如一个日历选择控件就认为是一个&lt;strong&gt;组件&lt;/strong&gt;。而&lt;strong&gt;模块&lt;/strong&gt;他们认为就是&lt;strong&gt;业务模块&lt;/strong&gt;，顾名思义，就是按业务划分而成的模块。而另一部分人则相反。&lt;/p&gt;

&lt;p&gt;在维基百科对模块化的解释中有这么一句：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;A component is a similar concept, but typically refers to a higher level; a component is a piece of a whole system, while a module is a piece of an individual program&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;也就是认为&lt;strong&gt;组件&lt;/strong&gt;粒度较&lt;strong&gt;模块&lt;/strong&gt;要更大，所以本文对&lt;strong&gt;组件&lt;/strong&gt;和&lt;strong&gt;模块&lt;/strong&gt;做出以下定义：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;组件&lt;/strong&gt;：侧重于业务，可编译成单独的app，一般只负责单一业务，具备自身的生命周期（通常包含Android四大组件的一个或多个，所以称之为组件也更加贴切）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;模块&lt;/strong&gt;：侧重于功能，与业务无关，比如自定义控件、网络请求库、图片加载库等&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;而从Android Studio推出之后，我们在开发项目时也会有意识的将一些可重用的代码逻辑抽离成一个个的&lt;strong&gt;Module&lt;/strong&gt;，这也就是模块化开发的雏形。当然，组件化开发也不是就尽善尽美的，下面列举了它的一些优缺点：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;优点：&lt;/strong&gt;一个复杂的系统可以由一个个组件集合而成，甚至于不同的组合可以构建出不同的系统。每个组件有独立的版本，可独立编译、打包，大大提高了系统的灵活性以及开发人员的开发效率。应用的更新可以精细到组件，组件的升级替换不会影响到其它组件，也不会受其它组件的限制。&lt;/p&gt;

&lt;p&gt;基于组件化架构设计的应用比传统的“单片”设计可重用性高得多，因为这些组件可以在其他项目中重用，而且开发人员无需了解整个应用，可以只专注于分配给他们的较小的任务，提高开发效率。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;缺点：&lt;/strong&gt;组件化的实施对开发人员和团队管理人员提出了更高水平的要求，项目管理难度更大。组件间如何进行通信也是需要慎重考虑的。万事开头难，在对一个项目进行组件化分解时就好像庖丁解牛一般，你需要了解项目的&lt;strong&gt;“肌理筋骨”&lt;/strong&gt;，才知道从何处下&lt;strong&gt;“刀”&lt;/strong&gt;，才能更轻易的去分解项目，这就要求架构师对于项目的整体需求了如指掌。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;下面就来谈谈我的&lt;strong&gt;组件化&lt;/strong&gt;之路。。。&lt;/p&gt;

&lt;p&gt;首先我负责的项目类似于一个远程控制应用，它与服务器建立Socket连接，接收服务器发送过来的指令，针对这些指令对当前Android设备执行关机、安装应用等操作。应用本身也会收集一些设备信息如应用运行日志，使用时长等，在某个指定的时间点上传至服务器。理想的组件间依赖关系是这样的：
&lt;img src=&#34;https://richardwrq.github.io/组件化之路/组件化架构.jpg&#34; alt=&#34;组件化架构&#34; /&gt;&lt;/p&gt;

&lt;p&gt;其中基础模块不能脱离主工程独立运行，组件之间不能直接依赖，组件间通信方式可以是接口也可以是事件总线。团队中的开发人员只需要关注自身负责的组件（在开发模式下各组件会转化为可单独运行的App，说白了就是在&lt;code&gt;build.gradle&lt;/code&gt;文件中将&lt;code&gt;apply plugin: &#39;com.android.library&#39;&lt;/code&gt;改为&lt;code&gt;apply plugin: &#39;com.android.application&#39;&lt;/code&gt;，网上有很多相关资料，在此就不赘述了）。&lt;/p&gt;

&lt;p&gt;现在来了个开发需求需要改动组件&lt;code&gt;Component1&lt;/code&gt;内部的逻辑，团队中的小A是负责该组件的开发人员，在接到需求后，小A啪啪啪一顿猛如虎的操作完成需求后，对该组件进行单元测试，检查组件输入输出，测试通过后提交代码，审核通过后构建平台构建、打包、发布，整个过程完全没有“惊动”其他组件，Perfect！&lt;/p&gt;

&lt;p&gt;然而现实是残酷的。。&lt;/p&gt;

&lt;p&gt;由于组件间不可能完全不通信，所以现实情况组件之间的依赖关系有可能是这样的：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://richardwrq.github.io/组件化之路/现实情况依赖关系.jpg&#34; alt=&#34;现实情况下的依赖关系&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;对比上图，组件之间显得更加“亲密无间”了，而且这还不是糟糕的情况，当组件越来越多，各种相互依赖，循坏依赖的问题会让你痛不欲生。&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;因为组件之间不可避免的存在需要通信的情况，比如 &lt;code&gt;Component1&lt;/code&gt;需要调用&lt;code&gt;Component2&lt;/code&gt;的方法一般情况下我们都是直接通过类名或对象引用的方式去调用相应的方法。但是这种通信方式正是导致组件之间高度耦合的罪魁祸首，所以必须杜绝这种通信方式。&lt;/p&gt;

&lt;p&gt;那么问题来了，怎么做到既能让组件间通信又高度解耦呢？这就需要用到文章开头提到的&lt;strong&gt;面向接口编程&lt;/strong&gt;思想和&lt;strong&gt;依赖注入&lt;/strong&gt;（或者叫依赖查找）技术。举个🌰：&lt;/p&gt;

&lt;p&gt;组件A中的&lt;code&gt;Foo1&lt;/code&gt;类依赖组件B&lt;code&gt;Foo2&lt;/code&gt;类中的&lt;code&gt;bar&lt;/code&gt;方法，一种比较low的实现方式是：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//ComponentA
class Foo1 {
    private Foo2 mFoo2;
    public void main() {
        mFoo2 = new Foo2();
        mFoo2.bar();
    }
}

//ComponentB
class Foo2 {
    public void bar() {
        //nop
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这种实现方式违反了&lt;a href=&#34;https://baike.baidu.com/item/%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE%E5%8E%9F%E5%88%99/6189149&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;控制反转&lt;/a&gt;设计原则，耦合度高，假如这时需求变更了，需要使用组件C的&lt;code&gt;Foo3&lt;/code&gt;类中的&lt;code&gt;bar()&lt;/code&gt;方法去替换原来的实现，那这下乐子就大了。&lt;/p&gt;

&lt;p&gt;而通过面向接口编程以及&lt;strong&gt;依赖注入&lt;/strong&gt;技术我们能很好的遵循控制反转设计原则：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//Common Component
interface IBar {
    void bar()
}

//ComponentA
class Foo1 {
    private IBar mBar;
    
    public void main() {
        if (mBar != null) {
            mBar.bar();
        }
    }
    
    public void setBar(IBar bar) {
        mBar = bar;
    }
}

//ComponentB
class Foo2 implements IBar {
    
    @Override
    public void bar() {
        //nop
    }
}

//ComponentC
class Foo3 implements IBar {
    
    @Override
    public void bar() {
        //nop
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这就是经典的实现了控制反转的示例代码，&lt;code&gt;Foo1&lt;/code&gt;类只知道自己需要一个实现了&lt;code&gt;IBar&lt;/code&gt;接口的实例，然后调用接口的&lt;code&gt;bar()&lt;/code&gt;方法，至于是谁去实现的这个接口，不好意思，它压根不关心。&lt;/p&gt;

&lt;p&gt;虽然你&lt;code&gt;Foo1&lt;/code&gt;类是舒服了，把依赖关系交给外部去解决了，但是总要有人去负责这部分的工作吧。这时候依赖注入容器（IOC容器）就登场了，如果对web开发有所了解的同学肯定不会感到陌生，&lt;code&gt;Spring&lt;/code&gt;就是一个IOC容器，这个容器把依赖查找，类实例化（其实就是根据类的路径名称通过反射进行实例化）这些脏活累活揽在身上，这样既实现了控制反转又极大提高了应用的灵活性和可维护性。&lt;/p&gt;

&lt;p&gt;正因为依赖注入能有效地降低代码之间的耦合度，所以基于依赖注入实现的&lt;strong&gt;组件化框架&lt;/strong&gt;（路由框架）也就应运而生了，目前主流的Android组件化框架有&lt;a href=&#34;https://github.com/alibaba/ARouter&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;ARouter&lt;/a&gt;、&lt;a href=&#34;https://github.com/luckybilly/CC&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;CC&lt;/a&gt;、&lt;a href=&#34;https://github.com/luojilab/DDComponentForAndroid&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;DDComponentForAndroid&lt;/a&gt;、&lt;a href=&#34;https://github.com/mzule/ActivityRouter&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;ActivityRouter&lt;/a&gt;等等，我自己也使用&lt;code&gt;Kotlin&lt;/code&gt;基于&lt;code&gt;kapt&lt;/code&gt;技术实现了一个路由框架&lt;a href=&#34;https://github.com/richardwrq/KRouter&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;KRouter&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;虽然相关的框架有很多，但是它们实现原理不外乎两种：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;一种是将分布在各个组件的类按照一定的规则在内部生成映射表，这个映射表的数据结构通常是一个Map，Key是一个字符串，Value是一个类或者是类的路径名称（用于通过反射进行类的实例化）。通俗来说就是类的查找，这种实现方式要求调用方和被调用方都持有接口类，通常这些共同持有的接口类会被定义在一个&lt;code&gt;Common&lt;/code&gt;基础模块中，而且在运行时这些相互通信的组件必须打包到同一个APK中。这种实现方式导致无法真正实现代码隔离（需要通信的两个组件仍然是存在依赖关系的），基于这种原理实现的组件化架构“自约束能力”很弱，因为无法约束开发人员通过直接引用的方式进行通信的行为，虽然一开始设计人员想的很美好，但是开发人员在实现时做出来的产品却不是那样，因为“自约束能力”弱的架构设计是通过“编码规范”、“测试驱动”甚至是“人员熟练度”来保证开发人员实现的代码符合设计人员的设计初衷，而且这种架构也无法保证后续接手维护项目的开发人员能够贯彻原本的设计思想，随着时间推移，项目往越来越糟糕的方向演进（解决这个问题最好的方案就是从编译器层面进行约束，也就是把问题拦截在编码阶段，然而Java9才支持模块化开发，Android目前还处于支持部分Java8的特性的阶段，路还很长）。&lt;/li&gt;
&lt;li&gt;另一种方案是基于事件总线的方式实现组件之间的通信，不再是面向接口编程，而是面向通信协议编程，可以理解为组件间的调用类似http请求。这些框架会在内部建立跨进程通信的连接（也就是事件总线），这条事件总线负责分发路由请求以及返回执行结果。这种实现方式的好处是真正可以实现代码隔离，组件可以运行在独立的进程中，但是只支持基本类型参数的转发。实现跨进程通信有很多方案，比如Android原生的四大组件、Socket、FileObserver、MemoryFile、基于AIDL的Messager等等，使用Android原生的好处是安全性方面的工作由Android帮我们完成了，而使用Socket则需要自己实现加密Socket。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;第一种方案适合小型的项目，因为这些项目通常都是单进程的，虽然这样设计的架构“自约束能力”弱，但是目前大多数Android项目团队开发人数也不会太多，所以管理难度较小，而第二种实现方案则更适合跨进程组件化的项目（组件一般运行在独立的进程中甚至一个组件就是一个APP）。&lt;/p&gt;

&lt;p&gt;在我看来Android的组件化是存在3个阶段的，第一个是从单工程项目过度到多模块的阶段；第二个是从多模块过度到多组件的阶段；第三个就是多组件独立进程的阶段。而目前大多数应用其实都是在第二个阶段或者介于第二和第三个阶段之间，所以对于这样的项目，选择一个既支持类查找方式，又支持事件总线的组件化框架是最合适的（这也是一开始设计&lt;strong&gt;KRouter&lt;/strong&gt;想要达到的效果，虽然目前暂时不支持跨进程组件。。。）&lt;/p&gt;

&lt;p&gt;在项目实施组件化过程中，其实真正耗费时间、精力的不是编码，而是一开始组件的划分以及组件单元测试的代码的编写。有可能因为一开始对业务的不熟悉，导致后期开发时发现组件划分的不够准确，需要加以调整；或者是对接口抽象的不够好，导致维护时频繁修改接口；还有可能在编写单元测试时觉得枯燥乏味而选择放弃。我们不能因为遇到这些困难就半途而废，或者是质疑自己的架构设计能力，没有哪一个架构设计是放之四海皆准的，有可能一个项目的架构设计放在另一个项目中就显得不那么合适了。所以好的架构设计还需要设计人员“因地制宜”的对一个比较通用的架构骨架进行查漏补缺，最后使其与实际项目更加契合。&lt;/p&gt;

&lt;p&gt;祝大家都能成为一个优秀的架构设计师。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>IntelliJ IDEA/Android Studio插件开发入门指南</title>
      <link>https://richardwrq.github.io/2018/ideaplugin/</link>
      <pubDate>Wed, 21 Nov 2018 15:13:22 +0800</pubDate>
      
      <guid>https://richardwrq.github.io/2018/ideaplugin/</guid>
      <description>

&lt;p&gt;基于IntelliJ平台的产品都可以通过添加插件来丰富其原有的功能，JetBrains团队也我们提供了丰富的API来进行插件开发，所有的插件都可以在&lt;a href=&#34;https://plugins.jetbrains.com/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;JetBrains Plugin Repository&lt;/a&gt;找到。常见的插件类型有：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;自定义语言支持（如Java、Kotlin）&lt;/li&gt;
&lt;li&gt;框架集成&lt;/li&gt;
&lt;li&gt;工具集成&lt;/li&gt;
&lt;li&gt;用户界面插件&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这些类型插件的介绍以及功能就不一一细说了，&lt;a href=&#34;http://www.jetbrains.org/intellij/sdk/docs/basics/getting_started.html&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;官网&lt;/a&gt;也有比较详细的介绍。
简单来说，IDEA也好Android Studio也好（以下统一称为IDE），它们为插件提供了运行环境，通过各种插件的配合来实现不同的功能。下面就先介绍开发IDEA插件前需要哪些准备。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.jetbrains.com/idea/?fromMenu&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;安装IDEA&lt;/a&gt;，如果想在开发插件的过程中进行Debug，那么还需要把IDEA的源码下载下来(&lt;a href=&#34;https://github.com/JetBrains/intellij-community&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;Github源码地址&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;配置IntelliJ Platform SDK，也就是开发插件所需的SDK，类似开发Android应用时需要Android SDK，并且插件都是运行在JVM上的，所以也需要配置JDK的路径&lt;/li&gt;
&lt;li&gt;指定&lt;strong&gt;Sandbox Home&lt;/strong&gt;目录，&lt;strong&gt;Sandbox Home&lt;/strong&gt;目录用于存放插件项目实例的一些配置文件。在macOS系统中默认存放路径是&lt;code&gt;/Users/{用户名}/Library/Caches/IdeaIC2018.2/plugins-sandbox&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;配置SDK，如果你把IDEA源码也下载了，那么还需要配置一下源码的路径
&lt;img src=&#34;https://richardwrq.github.io/IDEAPlugin/添加SDK.jpg&#34; alt=&#34;添加SDK&#34; /&gt;
&lt;img src=&#34;https://richardwrq.github.io/IDEAPlugin/选择源码路径.jpg&#34; alt=&#34;添加源码&#34; /&gt;&lt;/p&gt;

&lt;p&gt;环境搭建好了，那么接下来我们就创建一个简易的插件工程，依次点击&lt;code&gt;File-&amp;gt;New-&amp;gt;Project&lt;/code&gt;然后在弹出框左栏选择&lt;code&gt;Gradle&lt;/code&gt;，然后在右侧一栏勾选&lt;code&gt;IntelliJ Platform Plugin&lt;/code&gt;（如果想要使用Kotlin进行开发就把&lt;code&gt;Kotlin&lt;/code&gt;那一项也勾选上）
&lt;img src=&#34;https://richardwrq.github.io/IDEAPlugin/新建插件项目.jpg&#34; alt=&#34;新建插件&#34; /&gt;
项目创建好后长这样：
&lt;img src=&#34;https://richardwrq.github.io/IDEAPlugin/项目结构.jpg&#34; alt=&#34;项目结构&#34; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;创建action&#34;&gt;创建Action&lt;/h1&gt;

&lt;p&gt;插件可以自定义IDE的UI，在菜单或工具栏中新加入一个Item。SDK提供了一个类&lt;code&gt;AnAction&lt;/code&gt;，这个类的&lt;code&gt;actionPerformed&lt;/code&gt;方法在你每次在菜单栏中选中或在工具栏中点击对应项时都会被调用。创建一个&lt;strong&gt;Action&lt;/strong&gt;只需要两步：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;定义派生于AnAction的类&lt;/li&gt;
&lt;li&gt;注册Action&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;当然你也可以定义一组派生于AnAction的类&lt;/code&gt;&lt;/p&gt;

&lt;h1 id=&#34;定义action&#34;&gt;定义Action&lt;/h1&gt;

&lt;p&gt;下面的代码是我仿照官方例子定义的一个Action，只是把Java改成了Kotlin实现&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Kotlin&#34;&gt;class TextBoxes : AnAction(&amp;quot;Text _Boxes&amp;quot;) {

    override fun actionPerformed(e: AnActionEvent) {
        val project = e.getData(PlatformDataKeys.PROJECT)//这个Project是不是很熟悉？它其实跟Gradle中的Project意义是一样的
        val txt = Messages.showInputDialog(project, &amp;quot;What is your name?&amp;quot;, &amp;quot;Input your name&amp;quot;, Messages.getQuestionIcon())
        Messages.showMessageDialog(project, &amp;quot;Hello, $txt!\\n I am glad to see you.&amp;quot;, &amp;quot;Information&amp;quot;, Messages.getInformationIcon())//这两段代码其实很简单，都不用解释了
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;注册action&#34;&gt;注册Action&lt;/h1&gt;

&lt;p&gt;定义好&lt;strong&gt;Action&lt;/strong&gt;之后当然就需要告知IDE你有哪些&lt;strong&gt;Action&lt;/strong&gt;啦，所以就需要对这些&lt;strong&gt;Action&lt;/strong&gt;进行注册，注册的方式有两种（是不是似曾相识的感觉？）。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在&lt;code&gt;plugin.xml&lt;/code&gt;文件的&lt;code&gt;&amp;lt;actions&amp;gt;&lt;/code&gt;标签中进行注册&lt;/li&gt;
&lt;li&gt;在代码中进行注册&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;在plugin-xml文件中进行注册&#34;&gt;在plugin.xml文件中进行注册&lt;/h1&gt;

&lt;p&gt;跟Android开发中在&lt;code&gt;AndroidManifest.xml&lt;/code&gt;文件中注册组件非常相像，我们只需要按照&lt;strong&gt;IntelliJ&lt;/strong&gt;平台的规范在&lt;code&gt;plugin.xml&lt;/code&gt;文件的&lt;code&gt;&amp;lt;actions&amp;gt;&lt;/code&gt;部分内容进行修改：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;actions&amp;gt;
  &amp;lt;group id=&amp;quot;MyPlugin.SampleMenu&amp;quot; text=&amp;quot;_Sample Menu&amp;quot; description=&amp;quot;Sample menu&amp;quot;&amp;gt;
    &amp;lt;add-to-group group-id=&amp;quot;MainMenu&amp;quot; anchor=&amp;quot;last&amp;quot;  /&amp;gt;
       &amp;lt;!--把这组Action加到&amp;quot;MainMenu&amp;quot;中--&amp;gt;
       &amp;lt;action id=&amp;quot;Myplugin.Textboxes&amp;quot; class=&amp;quot;Mypackage.TextBoxes&amp;quot; text=&amp;quot;Text _Boxes&amp;quot; description=&amp;quot;A test menu item&amp;quot; /&amp;gt;
  &amp;lt;/group&amp;gt;
&amp;lt;/actions&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面对&lt;code&gt;plugin.xml&lt;/code&gt;的规范做一些介绍：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!-- Actions --&amp;gt;
    &amp;lt;actions&amp;gt;
    &amp;lt;!-- &amp;lt;action&amp;gt;对Action进行注册，
         &amp;quot;id&amp;quot;定义了这个Action的唯一识别id，
         &amp;quot;class&amp;quot;用于指定该Action对应类的全路径，
         &amp;quot;text&amp;quot;定义这个Action在菜单栏或者工具栏中显示的文本，前面加_表示在该字符下加下划线，
         &amp;quot;use-shortcut-of&amp;quot; 可选项 指定使用和某一个Action一样的快捷键
         &amp;quot;description&amp;quot; 可选项 对Action的描述（当你的鼠标指针停留在该item时就会显示该内容）
         &amp;quot;icon&amp;quot;没啥好说的--&amp;gt;
    &amp;lt;action id=&amp;quot;VssIntegration.GarbageCollection&amp;quot; class=&amp;quot;com.foo.impl.CollectGarbage&amp;quot; text=&amp;quot;Collect _Garbage&amp;quot; description=&amp;quot;Run garbage collector&amp;quot; icon=&amp;quot;icons/garbage.png&amp;quot;&amp;gt;
        &amp;lt;!-- &amp;lt;add-to-group&amp;gt;节点表示指定Action被加入到已存在的一个组中，
             &amp;quot;group-id&amp;quot;表示加入的组的id，
             &amp;quot;anchor&amp;quot;指定Action相对于组中其他Action的位置，可以指定的值有&amp;quot;first&amp;quot;, &amp;quot;last&amp;quot;, &amp;quot;before&amp;quot;, &amp;quot;after&amp;quot;
             &amp;quot;relative-to-action&amp;quot;如果把&amp;quot;anchor&amp;quot;的值设置为&amp;quot;before&amp;quot;或者&amp;quot;after&amp;quot;时，必须为该属性赋值，表示相对于某一个Action的位置--&amp;gt;
        &amp;lt;add-to-group group-id=&amp;quot;ToolsMenu&amp;quot; relative-to-action=&amp;quot;GenerateJavadoc&amp;quot; anchor=&amp;quot;after&amp;quot;/&amp;gt;
        &amp;lt;!-- &amp;lt;keyboard-shortcut&amp;gt;指定Action的快捷键
             &amp;quot;second-keystroke&amp;quot;指定Action次选快捷键
             &amp;quot;keymap&amp;quot;指定Action的快捷键映射到哪一个系统中，可以设定的值作为常量定义在
             com.intellij.openapi.keymap.KeymapManager类中--&amp;gt;
        &amp;lt;keyboard-shortcut first-keystroke=&amp;quot;control alt G&amp;quot; second-keystroke=&amp;quot;C&amp;quot; keymap=&amp;quot;$default&amp;quot;/&amp;gt;
        &amp;lt;!-- 指定鼠标快捷键 --&amp;gt;
        &amp;lt;mouse-shortcut keystroke=&amp;quot;control button3 doubleClick&amp;quot; keymap=&amp;quot;$default&amp;quot;/&amp;gt;
    &amp;lt;/action&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;使用代码进行注册&#34;&gt;使用代码进行注册&lt;/h1&gt;

&lt;p&gt;使用代码注册其实也没什么少介绍的，贴一段官方代码大家就大致了解了，就是调用相应的api去做一些配置&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;public class MyPluginRegistration implements ApplicationComponent {
  // Returns the component name (any unique string value).
  @NotNull public String getComponentName() {
    return &amp;quot;MyPlugin&amp;quot;;
  }


  // If you register the MyPluginRegistration class in the &amp;lt;application-components&amp;gt; section of
  // the plugin.xml file, this method is called on IDEA start-up.
  public void initComponent() {
    ActionManager am = ActionManager.getInstance();
    TextBoxes action = new TextBoxes();

    // Passes an instance of your custom TextBoxes class to the registerAction method of the ActionManager class.
    am.registerAction(&amp;quot;MyPluginAction&amp;quot;, action);

    // Gets an instance of the WindowMenu action group.
    DefaultActionGroup windowM = (DefaultActionGroup) am.getAction(&amp;quot;WindowMenu&amp;quot;);

    // Adds a separator and a new menu command to the WindowMenu group on the main menu.
    windowM.addSeparator();
    windowM.add(action);
  }

  // Disposes system resources.
  public void disposeComponent() {
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面两种注册方式是不是都感觉挺麻烦，在AS中我们创建一个Activity的时候可以通过&lt;code&gt;File-&amp;gt;New-&amp;gt;Activity&lt;/code&gt;来帮我们创建一个Activity，并且已经帮我们注册到&lt;code&gt;AndroidManifest.xml&lt;/code&gt;中，甚至是布局文件也创建好了，那么IDEA能做到吗？答案是肯定的，而且步骤也大同小异：
&lt;img src=&#34;https://richardwrq.github.io/IDEAPlugin/快速创建Action.jpg&#34; alt=&#34;快速创建Action&#34; /&gt;&lt;/p&gt;

&lt;p&gt;接下来我们点击运行或&lt;code&gt;Debug&lt;/code&gt;即可看到运行效果
&lt;img src=&#34;https://richardwrq.github.io/IDEAPlugin/运行效果1.jpg&#34; alt=&#34;运行效果1&#34; /&gt;
&lt;img src=&#34;https://richardwrq.github.io/IDEAPlugin/运行效果2.jpg&#34; alt=&#34;运行效果2&#34; /&gt;
&lt;img src=&#34;https://richardwrq.github.io/IDEAPlugin/运行效果3.jpg&#34; alt=&#34;运行效果3&#34; /&gt;&lt;/p&gt;

&lt;p&gt;到这里相信你也了解了怎么样去创建并运行一个简单的IDEA插件了，整个过程是不是和开发一个Android应用非常相像呢，其实都可以把他们看成是开发一个带UI界面的JVM应用程序，当你开发好一个插件之后，需要将其上传到远程仓库中以供他人使用，整个流程和发布一个第三方库也是大同小异。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>注解处理器Annotation Processor中判断Java或Kotlin类</title>
      <link>https://richardwrq.github.io/2018/judgejavaorkt/</link>
      <pubDate>Fri, 27 Apr 2018 19:45:50 +0800</pubDate>
      
      <guid>https://richardwrq.github.io/2018/judgejavaorkt/</guid>
      <description>&lt;p&gt;在Android Studio中，项目编译build之后kapt会在项目的&lt;code&gt;build/tmp/kapt3/stubs&lt;/code&gt;目录下会生成kotlin编写的类的Java“存根类”，在这些类的顶部我们可以看到有这样一个注解&lt;code&gt;@kotlin.Metadata(...)&lt;/code&gt;
 &lt;code&gt;@Metadata&lt;/code&gt;是 Kotlin 里比较特殊的一个注解。它记录了 Kotlin 代码元素的一些信息，比如 class 的可见性，function 的返回值，参数类型，property 的 lateinit，nullable 的属性等等。这些 Metadata 的信息由 kotlinc 生成，最终会以注解的形式存于 .class 文件。
所以要在注解处理器判断一个类是kotlin语言或者Java语言编写的我们可以通过判断该类是否有&lt;code&gt;@Metadata&lt;/code&gt;注解来区分：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;    /**
     * if true mean this class is java class
     */
    private fun isJavaFile(element: TypeElement): Boolean {
        val tmMetadata = mElements.getTypeElement(&amp;quot;kotlin.Metadata&amp;quot;).asType()
        return element.annotationMirrors.find { it.annotationType == tmMetadata } == null
    }
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>使用Kotlin打造Android路由框架-Krouter</title>
      <link>https://richardwrq.github.io/2018/krouter/</link>
      <pubDate>Fri, 27 Apr 2018 12:35:27 +0800</pubDate>
      
      <guid>https://richardwrq.github.io/2018/krouter/</guid>
      <description>

&lt;p&gt;&lt;strong&gt;KRouter&lt;/strong&gt;(&lt;a href=&#34;https://github.com/richardwrq/KRouter)路由框架借助gradle插件、[kapt](https://blog.jetbrains.com/kotlin/2015/05/kapt-annotation-processing-for-kotlin/)实现了依赖注入、为Android平台页面启动提供路由功能。&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://github.com/richardwrq/KRouter)路由框架借助gradle插件、[kapt](https://blog.jetbrains.com/kotlin/2015/05/kapt-annotation-processing-for-kotlin/)实现了依赖注入、为Android平台页面启动提供路由功能。&lt;/a&gt;
源码不复杂，在关键地方也有注释说明，建议打算或正在使用kapt+kotlinpoet遇到坑的同学可以fork一下项目，或许能找到你想要的答案，只要将整个流程了解清楚了，相信你自己也能撸一个轮子出来，目前许多开源框架&lt;code&gt;dagger&lt;/code&gt;、&lt;code&gt;butter knife&lt;/code&gt;、&lt;code&gt;greendao&lt;/code&gt;等实现原理都是一致的。
####从startActivity开始说起
在组件化开发的实践过程中，当我完成一个模块的开发后（比如说这个模块中有一个Activity或者Service供调用者调用），其他模块的开发者要启动我这个模块中的Activity的代码我们再熟悉不过了：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;    val intent = Intent(this, MainActivity::class.java)
    intent.putExtra(&amp;quot;param1&amp;quot;, &amp;quot;1&amp;quot;)
    intent.putExtra(&amp;quot;param2&amp;quot;, &amp;quot;2&amp;quot;)
    startActivity(intent)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然，其他模块的开发人员需要知道我们这个Activity的类名以及传入的参数对应的key值（上面的param1和param2），这时候我就想，在每一个需要启动这个页面的地方都存在着类似的样板代码，而且被启动的Activity在取出参数对属性进行赋值时的代码也比较繁琐，于是在网上查找相关资料了解到目前主流的路由框架（ARouter、Router等）都支持这些功能，秉着尽量不重复造轮子的观念我fork了ARouter项目，但是阅读源码后发现其暂时不支持Service的启动，而我负责的项目里面全是运行在后台的Service。。。紧接着也大概了解了一下其他一些框架，都存在一些不太满意的地方，考虑再三，干脆自己撸一个轮子出来好了。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;首先来看一段最简单的发起路由请求的代码(Java调用)：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;    KRouter.INSTANCE.create(&amp;quot;krouter/main/activity?test=32&amp;quot;)
                    .withFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP)
                    .withString(&amp;quot;test2&amp;quot;, &amp;quot;this is test2&amp;quot;)
                    .request();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中&lt;code&gt;krouter/main/activity?test=32&lt;/code&gt;为对应的路由路径，可以使用类似http请求的格式，在问号后紧接着的是请求参数，这些参数最终会自动包装在intent的extras中，也可以通过调用&lt;code&gt;with&lt;/code&gt;开头的函数来配置请求参数。
上面的代码执行后最终会启动一个Activity，准确来说是一个带有&lt;code&gt;@Route&lt;/code&gt;注解的Activity，它长这样：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;    @Route(path = &amp;quot;krouter/main/activity&amp;quot;)
    public class MainActivity extends Activity {
        ...
        @Override
        protected void onCreate(Bundle savedInstanceState) {
            super.onCreate(savedInstanceState);
            setContentView(R.layout.activity_main);
            getIntent().getIntExtra(&amp;quot;test&amp;quot;, -1);//这里可以获取到请求参数test
        }
        ...
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是一个最基本的功能，怎么样，看起来还不错吧？跟大部分路由框架的调用方式差不多。现在主流的路由框架是怎么做到的呢？下面就看我一一道来。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;在使用&lt;code&gt;KRouter&lt;/code&gt;的API前首先需要为一些类添加注解：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;/**
 * User: WuRuiqiang(263454190@qq.com)
 * Date: 18/1/2
 * Time: 上午10:53
 * Version: v1.0
 * Description：用于标记可路由的组件
 */
@Target(AnnotationTarget.CLASS)
@Retention(AnnotationRetention.SOURCE)
annotation class Route(
        /**
         * Path of route
         */
        val path: String,
        /**
         * PathPrefix of route
         */
        val pathPrefix: String = &amp;quot;&amp;quot;,
        /**
         * PathPattern of route
         */
        val pathPattern: String = &amp;quot;&amp;quot;,
        /**
         * Name of route
         */
        val name: String = &amp;quot;undefined&amp;quot;,
        /**
         * Priority of route
         */
        val priority: Int = -1)

/**
 * User: WuRuiqiang(263454190@qq.com)
 * Date: 18/1/2
 * Time: 上午10:53
 * Version: v1.0
 * Description：用于拦截路由的拦截器
 */
@Target(AnnotationTarget.CLASS)
@Retention(AnnotationRetention.SOURCE)
annotation class Interceptor(
        /**
         * Priority of interceptor
         */
        val priority: Int = -1,
        /**
         * Name of interceptor
         */
        val name: String = &amp;quot;DefaultInterceptor&amp;quot;)

/**
 * User: WuRuiqiang(263454190@qq.com)
 * Date: 18/1/2
 * Time: 上午10:53
 * Version: v1.0
 * Description：属性注入
 */
@Target(AnnotationTarget.FIELD)
@Retention(AnnotationRetention.SOURCE)
annotation class Inject(
        /**
         * Name of property
         */
        val name: String = &amp;quot;&amp;quot;,
        /**
         * If true, app will be throws NPE when value is null
         */
        val isRequired: Boolean = false,
        /**
         * Description of the field
         */
        val desc: String = &amp;quot;No desc.&amp;quot;)

/**
 * User: WuRuiqiang(263454190@qq.com)
 * Date: 18/1/2
 * Time: 上午10:53
 * Version: v1.0
 * Description：Provider
 */
@Target(AnnotationTarget.CLASS)
@Retention(AnnotationRetention.SOURCE)
annotation class Provider(/**
                           * Path of Provider
                           */
                          val value: String)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;被注解的元素的信息最终被保存在对应的数据类中：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;/**
 * User: WuRuiqiang(263454190@qq.com)
 * Date: 18/1/4
 * Time: 上午10:46
 * Version: v1.0
 * Description：Route元数据，用于存储被[com.github.richardwrq.krouter.annotation.Route]注解的类的信息
 */
data class RouteMetadata(
        /**
         * Type of Route
         */
        val routeType: RouteType = RouteType.UNKNOWN,
        /**
         * Priority of route
         */
        val priority: Int = -1,
        /**
         * Name of route
         */
        val name: String = &amp;quot;undefine&amp;quot;,
        /**
         * Path of route
         */
        val path: String = &amp;quot;&amp;quot;,
        /**
         * PathPrefix of route
         */
        val pathPrefix: String = &amp;quot;&amp;quot;,
        /**
         * PathPattern of route
         */
        val pathPattern: String = &amp;quot;&amp;quot;,
        /**
         * Class of route
         */
        val clazz: Class&amp;lt;*&amp;gt; = Any::class.java)
/**
 * User: WuRuiqiang(263454190@qq.com)
 * Date: 18/1/8
 * Time: 下午10:46
 * Version: v1.0
 * Description：Interceptor元数据，用于存储被[com.github.richardwrq.krouter.annotation.Interceptor]注解的类的信息
 */
data class InterceptorMetaData(
        /**
         * Priority of Interceptor
         */
        val priority: Int = -1,
        /**
         * Name of Interceptor
         */
        val name: String = &amp;quot;undefine&amp;quot;,
        /**
         * Class desc of Interceptor
         */
        val clazz: Class&amp;lt;*&amp;gt; = Any::class.java)

/**
 * User: WuRuiqiang(263454190@qq.com)
 * Date: 18/3/14
 * Time: 上午1:28
 * Version: v1.0
 * Description：Injector元数据，用于存储被[com.github.richardwrq.krouter.annotation.Inject]注解的类的信息
 */
data class InjectorMetaData(
        /**
         * if true, throw NPE when the filed is null
         */
        val isRequired: Boolean = false,
        /**
         * key
         */
        val key: String = &amp;quot;&amp;quot;,
        /**
         * field name
         */
        val fieldName: String = &amp;quot;&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中被&lt;strong&gt;@Route&lt;/strong&gt;注解的类是Android中的四大组件和Fragment或者它们的子类（目前尚不支持Broadcast以及ContentProvider），被&lt;strong&gt;@Route&lt;/strong&gt;注解的对象目前有3种处理方式：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;若被注解的类是Activity的子类，那么最终的处理方式是startActivity；&lt;/li&gt;
&lt;li&gt;若被注解的类是Service的子类，最终的处理方式有两种，也就  是Android中启动Service的两种方式，使用哪种启动方式取决于是否调用了&lt;code&gt;withServiceConn&lt;/code&gt;函数添加了ServiceConnection；&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;若被注解的类是Fragment的子类，最终的处理方式是调用无参构造函数构造出这个类的实例，并调用&lt;code&gt;setArguments(Bundle args)&lt;/code&gt;将请求参数传入Fragment的bundle中，最后返回该实例&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;被&lt;strong&gt;@Interceptor&lt;/strong&gt;注解的类需实现&lt;strong&gt;IRouteInterceptor&lt;/strong&gt;接口，这些类主要处理是否拦截路由的逻辑，比如某些需要登录才能启动的组件，就可以用到拦截器
&lt;strong&gt;@Inject&lt;/strong&gt;用于标记需要被注入的属性
被&lt;strong&gt;@Provider&lt;/strong&gt;注解的类最终可以调用&lt;code&gt;KRouter.getProvider(path: String)&lt;/code&gt;方法获取该类的对象，如果该类实现了&lt;strong&gt;IProvider&lt;/strong&gt;接口，那么&lt;code&gt;init(context: Context)&lt;/code&gt;方法将被调用
这些注解最终都不会被编译进class文件中，在编译时期这些注解会被收集起来最终交由不同的Annotation Processor去处理。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;KRouter&lt;/strong&gt;路由框架分为3个模块：
- &lt;strong&gt;KRouter-api&lt;/strong&gt;模块，作为SDK提供API供应用调用，调用&lt;strong&gt;KRouter-compiler&lt;/strong&gt;模块生成的类中的方法加载路由表，处理路由请求
- &lt;strong&gt;KRouter-compiler&lt;/strong&gt;模块，各种注解对应的Processor的集合，编译期运行，负责收集路由组件，并生成kotlin代码
- &lt;strong&gt;KRouter-gradle-plugin&lt;/strong&gt;模块，自定义gradle插件，在项目构建时期添加相关依赖以及相关参数的配置&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://upload-images.jianshu.io/upload_images/745509-d2b8cacc05798b3f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;各模块运行时期.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;#####KRouter-compiler
在介绍该模块之前如果有同学不知道&lt;strong&gt;Annotation Processor&lt;/strong&gt;的话建议先阅读 &lt;a href=&#34;http://blog.csdn.net/hj7jay/article/details/52180023&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;Annotation Processing-Tool详解&lt;/a&gt;， &lt;a href=&#34;http://blog.csdn.net/u013045971/article/details/53509237&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;一小时搞明白注解处理器（Annotation Processor Tool）&lt;/a&gt;这两篇文章，简单来说，APT就是&lt;code&gt;javac&lt;/code&gt;提供的一个插件，它会搜集被指定注解所注解的元素（类、方法或者属性），最终将搜集到的这些交给注解处理器&lt;strong&gt;Annotation Processor&lt;/strong&gt;进行处理，注解处理器通常会生成一些新的代码（推荐大名鼎鼎的square团队造的轮子&lt;strong&gt;&lt;a href=&#34;https://github.com/square/javapoet&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;javapoet&lt;/a&gt;&lt;/strong&gt;，这个开源库提供了非常友好的API让我们去生成Java代码），这些新生成的代码会与源码一起在同一个编译时期进行编译。
但是&lt;strong&gt;Annotation Processor&lt;/strong&gt;是&lt;code&gt;javac&lt;/code&gt;提供的一个插件，也就是说它只认识Java代码，它压根不知道kotlin是什么，所以如果是用kotlin编写的代码文件最终将会被&lt;code&gt;javac&lt;/code&gt;给忽略，所幸的是JetBrains在2015年就推出了&lt;a href=&#34;https://blog.jetbrains.com/kotlin/2015/05/kapt-annotation-processing-for-kotlin/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;kapt&lt;/a&gt;来解决这一问题。而且既然有javapoet，那square那么牛逼的团队肯定也会造一个生成kotlin代码的轮子吧，果不其然，在github一搜kotlinpoet，还真有，所以最终决定&lt;strong&gt;KRouter-compiler&lt;/strong&gt;模块使用&lt;strong&gt;kapt&lt;/strong&gt;+&lt;strong&gt;&lt;a href=&#34;https://github.com/square/kotlinpoet&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;kotlinpoet&lt;/a&gt;&lt;/strong&gt;来自动生成代码（kotlinpoet文档过于简单了，建议使用该库的同学通过它的测试用例或者参照Javapoet文档了解API的调用）。&lt;/p&gt;

&lt;p&gt;开头的例子中我们可以看到使用&lt;strong&gt;KRouter&lt;/strong&gt;启动一个Activity只需要知道该Activity的路径即可，并不需要像Android原生的启动方式一样传入&lt;code&gt;Class&amp;lt;*&amp;gt;&lt;/code&gt;或者&lt;code&gt;Class Name&lt;/code&gt;，那么&lt;strong&gt;KRouter&lt;/strong&gt;是怎么做到的呢？
原理很简单，&lt;strong&gt;KRouter-compiler&lt;/strong&gt;模块生了初始化&lt;code&gt;路由表&lt;/code&gt;的代码，这些&lt;code&gt;路由表&lt;/code&gt;内部其实就是一个个map，这些map以路径path作为key，数据类作为value（比如&lt;strong&gt;RouteMetadata&lt;/strong&gt;），SDK内部会通过path获取到数据类，像开头启动Activity的例子中，SDK就通过path获取到一个&lt;strong&gt;RouteMetadata&lt;/strong&gt;对象，在这个对象中取出被注解的类的&lt;code&gt;Class&amp;lt;*&amp;gt;&lt;/code&gt;，有了这个&lt;code&gt;Class&amp;lt;*&amp;gt;&lt;/code&gt;就可以完成启动Activity的操作。
接下来说说&lt;code&gt;路由表&lt;/code&gt;初始化代码生成之后是怎么被执行的，首先我定义了这样一些接口：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;/**
 * 加载路由
 *
 * @author: Wuruiqiang &amp;lt;a href=&amp;quot;mailto:263454190@qq.com&amp;quot;&amp;gt;Contact me.&amp;lt;/a&amp;gt;
 * @version: v1.0
 * @since: 18/1/4 下午6:38
 */
interface IRouteLoader {
    fun loadInto(map: MutableMap&amp;lt;String, RouteMetadata&amp;gt;)
}

/**
 * 加载拦截器
 *
 * @author: Wuruiqiang &amp;lt;a href=&amp;quot;mailto:263454190@qq.com&amp;quot;&amp;gt;Contact me.&amp;lt;/a&amp;gt;
 * @version: v1.0
 * @since: 18/1/5 上午9:12
 */
interface IInterceptorLoader {
    fun loadInto(map: TreeMap&amp;lt;Int, InterceptorMetaData&amp;gt;)
}

/**
 * 加载Provider
 *
 * @author: Wuruiqiang &amp;lt;a href=&amp;quot;mailto:263454190@qq.com&amp;quot;&amp;gt;Contact me.&amp;lt;/a&amp;gt;
 * @version: v1.0
 * @since: 18/1/5 上午9:12
 */
interface IProviderLoader {
    fun loadInto(map: MutableMap&amp;lt;String, Class&amp;lt;*&amp;gt;&amp;gt;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以&lt;strong&gt;@Route&lt;/strong&gt;注解为例，在&lt;strong&gt;KRouter-compiler&lt;/strong&gt;中定义了一个继承自&lt;strong&gt;AbstractProcessor&lt;/strong&gt;的类&lt;strong&gt;RouteProcessor&lt;/strong&gt;，在编译期间编译器会收集&lt;strong&gt;@Route&lt;/strong&gt;注解的元素的信息然后交由&lt;strong&gt;RouteProcessor&lt;/strong&gt;处理，&lt;strong&gt;RouteProcessor&lt;/strong&gt;会生成一个实现了&lt;strong&gt;IRouteLoader&lt;/strong&gt;接口的类，在&lt;code&gt;loadInto&lt;/code&gt;方法中把注解中的元数据与被注解的元素的部分信息存到&lt;strong&gt;RouteMetadata&lt;/strong&gt;对象，然后将注解的路径path作为key，&lt;strong&gt;RouteMetadata&lt;/strong&gt;对象作为value保存在一个map当中。生成的代码如下（项目build之后可以在&lt;code&gt;(module)/build/generated/source/kaptKotlin/(buildType)&lt;/code&gt;目录下找到这些自动生成的类）：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;/**
 *    ***************************************************
 *    * THIS CODE IS GENERATED BY KRouter, DO NOT EDIT. *
 *    ***************************************************
 */
class KRouter_RouteLoader_app : IRouteLoader {
    override fun loadInto(map: MutableMap&amp;lt;String, RouteMetadata&amp;gt;) {
        map[&amp;quot;krouter/sample/MainActivity&amp;quot;] = RouteMetadata(RouteType.ACTIVITY, -1, &amp;quot;undefined&amp;quot;, &amp;quot;krouter/sample/MainActivity&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;&amp;quot;, MainActivity::class.java)
        map[&amp;quot;myfragment&amp;quot;] = RouteMetadata(RouteType.FRAGMENT_V4, -1, &amp;quot;undefined&amp;quot;, &amp;quot;myfragment&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;&amp;quot;, MainActivity.MyFragment::class.java)
        map[&amp;quot;krouter/sample/fragment1&amp;quot;] = RouteMetadata(RouteType.FRAGMENT, -1, &amp;quot;undefined&amp;quot;, &amp;quot;krouter/sample/fragment1&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;&amp;quot;, Fragment1::class.java)
        map[&amp;quot;krouter/sample/fragment2&amp;quot;] = RouteMetadata(RouteType.FRAGMENT, -1, &amp;quot;undefined&amp;quot;, &amp;quot;krouter/sample/fragment2&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;&amp;quot;, Fragment2::class.java)
        map[&amp;quot;krouter/sample/Main2Activity&amp;quot;] = RouteMetadata(RouteType.ACTIVITY, -1, &amp;quot;undefined&amp;quot;, &amp;quot;krouter/sample/Main2Activity&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;&amp;quot;, Main2Activity::class.java)
        map[&amp;quot;krouter/sample/Main3Activity&amp;quot;] = RouteMetadata(RouteType.ACTIVITY, -1, &amp;quot;undefined&amp;quot;, &amp;quot;krouter/sample/Main3Activity&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;&amp;quot;, Main3Activity::class.java)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;代码生成之后，我们需要执行&lt;code&gt;loadInto&lt;/code&gt;方法才算是把数据存入到map中去，我们可以通过&lt;code&gt;Class.forName(ClassName).newInstance()&lt;/code&gt;获取该类实例，然后将其强制转换为&lt;strong&gt;IRouteLoader&lt;/strong&gt;类型，接着调用&lt;code&gt;loadInto&lt;/code&gt;方法传入map即可，现在问题来了，加载一个类我们需要知道这个类的路径和名称：&lt;code&gt;com.x.y.ClassA&lt;/code&gt;，但是SDK并不知道&lt;strong&gt;KRouter-compiler&lt;/strong&gt;会生成哪些类。
为此我准备了两种解决方案：
1. 类似&lt;code&gt;ARouter&lt;/code&gt;的做法，扫描所有dex文件，找出实现了&lt;code&gt;ARouter&lt;/code&gt;接口的类，然后将这些类的ClassName缓存至本地，下次应用启动时如果存在缓存且没有新增文件则读取缓存内容即可；
2. 第二种是生成的类及其路径遵循一定的规则，比如由&lt;strong&gt;RouteProcessor&lt;/strong&gt;生成的类路径规定为&lt;code&gt;com.github.richardwrq.krouter&lt;/code&gt;，类名规定以“KRouter_RouteLoader_”作为开头然后拼接上Module名称（以Module名称作为后缀是避免在不同的Module下生成类名一样的类，导致编译时出现类重复定义异常），所以&lt;strong&gt;RouteProcessor&lt;/strong&gt;名称为&lt;code&gt;app&lt;/code&gt;的Module下生成的类就是&lt;code&gt;com.github.richardwrq.krouter.KRouter_RouteLoader_app&lt;/code&gt;，在程序运行的时候，我们的SDK只需要获取项目中所有Module的名称，然后依次加载它们并执行&lt;code&gt;loadInto&lt;/code&gt;方法即可。&lt;/p&gt;

&lt;p&gt;基于性能考虑我采取了第二种方案，这就需要解决一个问题，因为&lt;strong&gt;RouteProcessor&lt;/strong&gt;是无法知道当前是处于哪个Module的，所以我们需要在Module的&lt;code&gt;build.gradle&lt;/code&gt;做如下配置：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;kapt {
    arguments {
        arg(&amp;quot;moduleName&amp;quot;, project.getName())
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样我们就配置了一个名为“moduleName”的参数，它的值就是当前Module的名称。这个参数可以在&lt;strong&gt;ProcessingEnvironment&lt;/strong&gt;的&lt;code&gt;getOptions()&lt;/code&gt;方法获取的map中取出，
&lt;strong&gt;Route&lt;/strong&gt;、&lt;strong&gt;Interceptor&lt;/strong&gt;、&lt;strong&gt;Provider&lt;/strong&gt;三者的处理流程大致相同，就不一一赘述了。
在这里提一下关于依赖注入&lt;strong&gt;Inject&lt;/strong&gt;的实现，关于如何对属性进行注入我想了两种解决方案：
1. 第一种就是通过反射，了解反射的同学都知道可以通过反射获取类的运行时注解，并且通过反射API为类的属性进行赋值，但由于时反射，所以性能上有所损耗，但是可以无视属性的访问权限；
2. 第二种是生成需要被注入的类的扩展方法，在扩展方法里面对接收者的属性进行赋值，性能更好，但是缺点是无法对private以及protected成员进行赋值。&lt;/p&gt;

&lt;p&gt;一开始是希望偷懒，就选择了第一种方案，但是问题来了，我知道Java的反射会有一些性能上的问题，但速度还不至于让用户感知明显，但是当我调用kotlin反射相关API时（最主要是获取Properties相关API），发现第一次调用花费的在4~5s 左右，之后调用速度是毫秒级的，我猜测是第一次调用加载了大量数据，然后将这些数据缓存起来了，但这4~5s的调用时间实在是恶心，所以最终还是决定采用方案2，有兴趣的同学可以查看&lt;code&gt;com/github/richardwrq/krouter/compiler/processor/RouteProcessor.kt&lt;/code&gt;，生成的代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class com_github_richardwrq_krouter_activity_Main2Activity_KRouter_Injector : IInjector {
    override fun inject(any: Any, extras: Bundle?) {
        val bundle = getBundle(any, extras)//getBundle为自动生成的顶层方法
        (any as Main2Activity).exInject(bundle)
    }

    private fun Main2Activity.exInject(bundle: Bundle) {
        person = bundle.get(&amp;quot;person&amp;quot;) as? Person ?: KRouter.getProvider&amp;lt;Person&amp;gt;(&amp;quot;person&amp;quot;) ?: parseObject(bundle.getString(&amp;quot;person&amp;quot;), object : TypeToken&amp;lt;Person&amp;gt;() {}.getType()) ?: throw java.lang.NullPointerException(&amp;quot;Field [person] must not be null in [Main2Activity]!&amp;quot;)//parseObject为自动生成的顶层方法
        provider = bundle.get(&amp;quot;NoImplProvider&amp;quot;) as? NoImplProvider ?: KRouter.getProvider&amp;lt;NoImplProvider&amp;gt;(&amp;quot;NoImplProvider&amp;quot;) ?: parseObject(bundle.getString(&amp;quot;NoImplProvider&amp;quot;), object : TypeToken&amp;lt;NoImplProvider&amp;gt;() {}.getType()) ?: throw java.lang.NullPointerException(&amp;quot;Field [provider] must not be null in [Main2Activity]!&amp;quot;)
        myProvider = (KRouter.getProvider&amp;lt;MyProvider&amp;gt;(&amp;quot;provider/myprovider&amp;quot;)) ?: throw java.lang.NullPointerException(&amp;quot;Field [myProvider] must not be null in [Main2Activity]!&amp;quot;)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;生成的类路径与扩展方法接收者的类路径相同（解决Java包内访问权限问题），类名命名规则为扩展方法接收者类路径的“.“替换为”_“作为前缀，后缀为”_KRouter_Injector“，比如被被注入的类是&lt;code&gt;com.github.richardwrq.krouter.activity.Main2Activity&lt;/code&gt;，那么自动生成的类为&lt;code&gt;com.github.richardwrq.krouter.activity.com_github_richardwrq_krouter_activity_Main2Activity_KRouter_Injector&lt;/code&gt;
#####KRouter-api
该模块其实就是提供API给用户调用的SDK
上面提到SDK需要执行&lt;strong&gt;KRouter-compiler&lt;/strong&gt;模块类的代码才能真正完成路由表初始化的工作，由于最终编译器会将所有Module打包成一个apk，所以在APP运行时是不存在Module的概念的，但是按照解决方案2各Module生成的类会以Module名称作为后缀，因此必须想办法让SDK获取到项目中所有Module的名称，考虑再三，我采取的解决方案是从&lt;code&gt;assets&lt;/code&gt;目录入手，在项目构建时期创建一个task，这个task会在Module的&lt;code&gt;src/main/assets&lt;/code&gt;目录下生成一个“KRouter&lt;em&gt;ModuleName”的文件，在SDK初始化的时候只需要列出&lt;code&gt;assets&lt;/code&gt;目录下所有&amp;rdquo;KRouter&lt;/em&gt;&amp;ldquo;开头的文件并截取下划线“_”后的内容，即可得到一个包含所有Module名称的列表。
下面给出SDK的类图，同学们可以对照源码参考
&lt;img src=&#34;https://upload-images.jianshu.io/upload_images/745509-9e7ee15fad22c478.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;KRouter-api类图.png&#34; /&gt;
#####KRouter-gradle-plugin
完成上述两个模块后其实&lt;code&gt;KRouter&lt;/code&gt;框架已经可以正常使用了，引用方式如下：
在各Module的&lt;code&gt;build.gradle&lt;/code&gt;加入下面的代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;kapt {
    arguments {
        arg(&amp;quot;moduleName&amp;quot;, project.getName())
    }
}
dependencies {
    implementation &#39;com.github.richardwrq:krouter-api:x.y.z’
    kapt &#39;com.github.richardwrq:krouter-compiler:x.y.z&#39;
}
afterEvaluate {
    //在assets目录创建文件的task
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当项目中Module较多时，手动在每一个Module加入这些配置未免有些蠢。。所以我写了一个gradle插件用来自动完成这些配置工作，具体实现参考源码，逻辑非常简单，最后使用引用方式变成下面这样：
在项目根目录&lt;code&gt;build.gradle&lt;/code&gt;文件加入如下配置&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;buildscript {

    dependencies {
        classpath &amp;quot;org.jetbrains.kotlin:kotlin-gradle-plugin:x.y.z&amp;quot;
        classpath &amp;quot;com.github.richardwrq:krouter-gradle-plugin:x.y.z&amp;quot;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后在各Module的&lt;code&gt;build.gradle&lt;/code&gt;文件加入如下配置&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;apply plugin: &#39;kotlin-android&#39;
apply plugin: &#39;kotlin-kapt&#39;
apply plugin: &amp;quot;com.github.richardwrq.krouter&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;到这里&lt;code&gt;KRouter&lt;/code&gt;路由框架就粗略的介绍了一遍，由于&lt;code&gt;kapt&lt;/code&gt;仍在不断完善，所以使用过程中难免碰到一些坑或者本身API功能不够完善，下面就列举一些遇到的问题以及解决方法：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.jianshu.com/p/f1ca4314f804&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;注解处理器Annotation Processor中判断Java或kotlin类&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.jianshu.com/p/f41d21850cb4&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;使用kotlinpoet生成kotlin代码数据类型不正确的问题&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;todolist&#34;&gt;ToDoList&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;通过gradle插件修改&lt;code&gt;AndroidManifest.xml&lt;/code&gt;文件，自动注册路由组件（Activity、Service）&lt;/li&gt;
&lt;li&gt;目前尚不支持动态加载的插件的路由注册，但有解决方案，hook classloader装载方法，在加载dex文件时扫描&lt;code&gt;KRouter&lt;/code&gt;的路由组件&lt;/li&gt;
&lt;li&gt;支持多应用多进程环境下的页面路&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title></title>
      <link>https://richardwrq.github.io/404/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://richardwrq.github.io/404/</guid>
      <description>

&lt;h1 id=&#34;error-404-page-not-found&#34;&gt;Error 404: Page Not Found&lt;/h1&gt;

&lt;hr /&gt;

&lt;h4 id=&#34;it-seems-that-the-page-that-you-re-trying-to-access-doesn-t-exist&#34;&gt;It seems that the page that you&amp;rsquo;re trying to access doesn&amp;rsquo;t exist. 😟&lt;/h4&gt;

&lt;h4 id=&#34;if-you-re-sure-that-it-exists-chances-are-it-might-have-been-moved-to-a-new-link-you-may-search-for-it-on-the-home-page&#34;&gt;If you&amp;rsquo;re sure that it exists, chances are it might have been moved to a new link! You may search for it on the home page.&lt;/h4&gt;
</description>
    </item>
    
    <item>
      <title></title>
      <link>https://richardwrq.github.io/about/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://richardwrq.github.io/about/</guid>
      <description>&lt;p&gt;一个程序员&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>