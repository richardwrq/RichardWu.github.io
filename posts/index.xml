<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on RichardWu&#39;s Blog</title>
    <link>https://richardwrq.github.io/posts/</link>
    <description>Recent content in Posts on RichardWu&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <lastBuildDate>Wed, 21 Nov 2018 15:13:22 +0800</lastBuildDate>
    
	<atom:link href="https://richardwrq.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>IntelliJ IDEA/Android Studio插件开发入门指南</title>
      <link>https://richardwrq.github.io/2018/ideaplugin/</link>
      <pubDate>Wed, 21 Nov 2018 15:13:22 +0800</pubDate>
      
      <guid>https://richardwrq.github.io/2018/ideaplugin/</guid>
      <description>基于IntelliJ平台的产品都可以通过添加插件来丰富其原有的功能，JetBrains团队也我们提供了丰富的API来进行插件开发，所有的插件都可以在JetBrains Plugin Repository找到。常见的插件类型有：
 自定义语言支持（如Java、Kotlin） 框架集成 工具集成 用户界面插件  这些类型插件的介绍以及功能就不一一细说了，官网也有比较详细的介绍。 简单来说，IDEA也好Android Studio也好（以下统一称为IDE），它们为插件提供了运行环境，通过各种插件的配合来实现不同的功能。下面就先介绍开发IDEA插件前需要哪些准备。
 安装IDEA，如果想在开发插件的过程中进行Debug，那么还需要把IDEA的源码下载下来(Github源码地址) 配置IntelliJ Platform SDK，也就是开发插件所需的SDK，类似开发Android应用时需要Android SDK，并且插件都是运行在JVM上的，所以也需要配置JDK的路径 指定Sandbox Home目录，Sandbox Home目录用于存放插件项目实例的一些配置文件。在macOS系统中默认存放路径是/Users/{用户名}/Library/Caches/IdeaIC2018.2/plugins-sandbox  配置SDK，如果你把IDEA源码也下载了，那么还需要配置一下源码的路径 环境搭建好了，那么接下来我们就创建一个简易的插件工程，依次点击File-&amp;gt;New-&amp;gt;Project然后在弹出框左栏选择Gradle，然后在右侧一栏勾选IntelliJ Platform Plugin（如果想要使用Kotlin进行开发就把Kotlin那一项也勾选上） 项目创建好后长这样： 创建Action 插件可以自定义IDE的UI，在菜单或工具栏中新加入一个Item。SDK提供了一个类AnAction，这个类的actionPerformed方法在你每次在菜单栏中选中或在工具栏中点击对应项时都会被调用。创建一个Action只需要两步：
 定义派生于AnAction的类 注册Action  当然你也可以定义一组派生于AnAction的类
定义Action 下面的代码是我仿照官方例子定义的一个Action，只是把Java改成了Kotlin实现
class TextBoxes : AnAction(&amp;quot;Text _Boxes&amp;quot;) { override fun actionPerformed(e: AnActionEvent) { val project = e.getData(PlatformDataKeys.PROJECT)//这个Project是不是很熟悉？它其实跟Gradle中的Project意义是一样的 val txt = Messages.showInputDialog(project, &amp;quot;What is your name?&amp;quot;, &amp;quot;Input your name&amp;quot;, Messages.getQuestionIcon()) Messages.showMessageDialog(project, &amp;quot;Hello, $txt!\\n I am glad to see you.</description>
    </item>
    
    <item>
      <title>注解处理器Annotation Processor中判断Java或Kotlin类</title>
      <link>https://richardwrq.github.io/2018/judgejavaorkt/</link>
      <pubDate>Fri, 27 Apr 2018 19:45:50 +0800</pubDate>
      
      <guid>https://richardwrq.github.io/2018/judgejavaorkt/</guid>
      <description>在Android Studio中，项目编译build之后kapt会在项目的build/tmp/kapt3/stubs目录下会生成kotlin编写的类的Java“存根类”，在这些类的顶部我们可以看到有这样一个注解@kotlin.Metadata(...) @Metadata是 Kotlin 里比较特殊的一个注解。它记录了 Kotlin 代码元素的一些信息，比如 class 的可见性，function 的返回值，参数类型，property 的 lateinit，nullable 的属性等等。这些 Metadata 的信息由 kotlinc 生成，最终会以注解的形式存于 .class 文件。 所以要在注解处理器判断一个类是kotlin语言或者Java语言编写的我们可以通过判断该类是否有@Metadata注解来区分：
/** * if true mean this class is java class */ private fun isJavaFile(element: TypeElement): Boolean { val tmMetadata = mElements.getTypeElement(&amp;quot;kotlin.Metadata&amp;quot;).asType() return element.annotationMirrors.find { it.annotationType == tmMetadata } == null }  </description>
    </item>
    
    <item>
      <title>使用Kotlin打造Android路由框架-Krouter</title>
      <link>https://richardwrq.github.io/2018/krouter/</link>
      <pubDate>Fri, 27 Apr 2018 12:35:27 +0800</pubDate>
      
      <guid>https://richardwrq.github.io/2018/krouter/</guid>
      <description>KRouter(https://github.com/richardwrq/KRouter)路由框架借助gradle插件、[kapt](https://blog.jetbrains.com/kotlin/2015/05/kapt-annotation-processing-for-kotlin/)实现了依赖注入、为Android平台页面启动提供路由功能。 源码不复杂，在关键地方也有注释说明，建议打算或正在使用kapt+kotlinpoet遇到坑的同学可以fork一下项目，或许能找到你想要的答案，只要将整个流程了解清楚了，相信你自己也能撸一个轮子出来，目前许多开源框架dagger、butter knife、greendao等实现原理都是一致的。 ####从startActivity开始说起 在组件化开发的实践过程中，当我完成一个模块的开发后（比如说这个模块中有一个Activity或者Service供调用者调用），其他模块的开发者要启动我这个模块中的Activity的代码我们再熟悉不过了：
val intent = Intent(this, MainActivity::class.java) intent.putExtra(&amp;quot;param1&amp;quot;, &amp;quot;1&amp;quot;) intent.putExtra(&amp;quot;param2&amp;quot;, &amp;quot;2&amp;quot;) startActivity(intent)  当然，其他模块的开发人员需要知道我们这个Activity的类名以及传入的参数对应的key值（上面的param1和param2），这时候我就想，在每一个需要启动这个页面的地方都存在着类似的样板代码，而且被启动的Activity在取出参数对属性进行赋值时的代码也比较繁琐，于是在网上查找相关资料了解到目前主流的路由框架（ARouter、Router等）都支持这些功能，秉着尽量不重复造轮子的观念我fork了ARouter项目，但是阅读源码后发现其暂时不支持Service的启动，而我负责的项目里面全是运行在后台的Service。。。紧接着也大概了解了一下其他一些框架，都存在一些不太满意的地方，考虑再三，干脆自己撸一个轮子出来好了。
首先来看一段最简单的发起路由请求的代码(Java调用)：
KRouter.INSTANCE.create(&amp;quot;krouter/main/activity?test=32&amp;quot;) .withFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP) .withString(&amp;quot;test2&amp;quot;, &amp;quot;this is test2&amp;quot;) .request();  其中krouter/main/activity?test=32为对应的路由路径，可以使用类似http请求的格式，在问号后紧接着的是请求参数，这些参数最终会自动包装在intent的extras中，也可以通过调用with开头的函数来配置请求参数。 上面的代码执行后最终会启动一个Activity，准确来说是一个带有@Route注解的Activity，它长这样：
@Route(path = &amp;quot;krouter/main/activity&amp;quot;) public class MainActivity extends Activity { ... @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); getIntent().getIntExtra(&amp;quot;test&amp;quot;, -1);//这里可以获取到请求参数test } ... }  这是一个最基本的功能，怎么样，看起来还不错吧？跟大部分路由框架的调用方式差不多。现在主流的路由框架是怎么做到的呢？下面就看我一一道来。
在使用KRouter的API前首先需要为一些类添加注解：
/** * User: WuRuiqiang(263454190@qq.com) * Date: 18/1/2 * Time: 上午10:53 * Version: v1.0 * Description：用于标记可路由的组件 */ @Target(AnnotationTarget.</description>
    </item>
    
  </channel>
</rss>